{
  "swagger": "2.0",
  "info": {
    "title": "DataTiger Management API",
    "description": "\n\n## Introduction \nThe Management API allows you to setup and configure a wide range of components:\n* Applications: Every domain (i.e. your company name), can have multiple applications. Each one has a unique name and is identified by a unique ID.  \n* Workflows: Every application can have multiple workflows. Often our workflows are also referred to as user journeys. Each one has a unique name and is identified by a unique ID.  \n* A/B Tests: we believe that you should be able to test pretty much everything you are doing, therefore A/B tests can be setup for all steps of a workflow. \n\n\n## General API concepts\n* Identifiers: All managed objects are uniquely identified by a platform generated identifier.\nThis is returned when an object is created or whenever it is retrieved from the database.\n\n* Versioning: Several entities (such as the workflows) are immutable entities, as modifying them can lead to unpredicted behaviour (e.g. modifying a workflow while \nit is executing). Updating such an entity results in a new version, with its own unique identifier. \n\n## Authentication\nMost requests need to be authenticated. Management API allows two types of authentication:\n  - API Key (Bearer token)\n  - Username/Password\n  \nAs Swagger 2.0 specification cannot properly describe these authentication schemes, please use this section as a reference on how the authentication works.    \n\nIn the following sections that describe the requests, all requests that require authentication will have an optional 'Authorization' header. The API user can either \nuse this header for API token authentication or an authenticated HTTP session for username/password authentication.     \n  \n### API Key authentication\nThe API key security model is mainly targeted for backends that use the DataTiger API. Each registered user account \nof a client is assigned a unique api key which can be used to uniquely identify the user account. \nWhen a client needs to access the DataTiger API they include the assigned API with each HTTP request to the API.\n\nThe HTTP header 'Authorization' is used to specify that the requestor holds a valid access token. \nEvery request to the API must include an Authorization header with a value of the following form:\n\n```\n  Authorization: Bearer <TokenString>\n```\nThe value after 'Bearer' is the actual API key. Note: The header name is *not* case sensitive.\n\nFor instance, getting the list of all available applications using curl:\n```\ncurl -X GET \\\nhttps://staging.api.datatiger.com/applications \\\n-H 'authorization: Bearer token_placeholder' \n```\n\n### Username/Password authentication\nThis is the traditional authentication scheme where a user is presented with a login form and is asked to enter a username and a password in order to identify themselves.\n\nUpon successful login, a session cookie is returned. Any subequent HTTP request can include the cookie in its request headers and the user will be  automatically identified \nthrough the associated server-side session.\n\nThe username/password pair should be passed by a POST request to the /account/login endpoint.\n\nThis authentication method is mostly targeted to the DataTiger frontend components. If a customer implements their own authentication, the API key authentication \nis more adequate.\n\n\nHere is an simple authentication example with curl:\n```\n  curl -X POST \\\n  https://staging.api.datatiger.com/account/login \\\n    -H 'content-type: application/x-www-form-urlencoded' \\\n    -d 'username=username_placeholder&password=password_placeholder'\\\n    -c cookieFile\n```\n\nAfter the session has been authenticated (session identifier is stored in the cookieFile), it can be used for further requests (e.g. retrieve the list of available\napplications):\n```\n  curl -X GET \\\n  https://staging.api.datatiger.com/applications \\\n  -b cookieFile\n```\n\n## Workflows\nThe active workflows of an application collectively define how the DataTiger platform reacts to incoming user events.  Each workflow belongs to a single application and has\na unique name within that application.\n\n### Workflow Versioning\nWorkflows are versioned in order to allow you to edit a workflow without impacting the instances of hte workflow that are already in progress. Versions are immutable, you can always create a new version but you can never edit an existing one. Among all the versions of a workflow a single one must be assigned the ACTIVE status and this version will be instantiated by the workflow engine in response to the incoming events.\nWhen you create a new version it is automatically assigned the DRAFT status. A version with this status can be edited as many times as needed, it is a mutable object. A draft version however cannot be set to ACTIVE. The version must first be brought to an immutable status by publishing the version. Publishing the version will set its status to PUBLISHED and make it effectively immutable. Once a version reaches the PUBLISHED status, it can then be made the active one. \nOnly a single version can be active at any one time. To activate a different version, the active version must first be de-activated by setting its status back to PUBLISHED and then another version that is already in the PUBLISHED status can be activated instead. \n\nFor a workflow to be instantiated from a user event the following conditions must be true:\n* The workflow must not be already in progress for that user \n* There must be a workflow version with a status of 'ACTIVE'\n* The trigger expression must evaluate to true\n\nWhen a workflow is activated, its steps are executed starting from the workflow starting step. The processing continues until the workflow reaches a final state or fails. Depending\non the workflow, its execution may require waiting until some action if performed. \n\n### Trigger expressions\nTrigger expressions are boolean expressions over the user and event attributes (available attributes and operations are returned by the /datatypes request).\nWithin a trigger expression, an event attribute is referenced using the 'event' prefix and a user attribute with the 'user' prefix.\n\nThe expressions consist of the following:\n* AND, OR and NOT operators\n* parentheses\n* user and event properties such as 'user.UserId' or 'event.EventType'\n* Operators: One of ==, ~ (case insensitive string equality), >, <, >=, <=, !=, in the last, not in the last, in the next, not in the next, is empty, is not empty, ends with, starts with, contains\n* Literals\n  * Strings: 'strings are enclosed in single quotes'\n  * DateTime: '2011-12-03T10:15:30'. The dateTimes are always expressed in UTC\n  * Boolean: true / false\n  * Integer: 1234, -1234\n  * Float: 1.01\n* Expressions relative to now\n  * user.LastActiveOn in the last 4 MINUTES\n  \n  \nA simple example expression is as follows:\n```\n  user.LastActiveOn in the last 1 DAYS AND event.eventType == 'UserUpdated'\n```\n#### Supported values for predefined user fields\nAt the moment certain user fields support a fixed set of values. Expressions are guaranteed to work only if they compare\nagainst the following exact values\n* user.TimezoneOffset\n      * −12\n      * −11\n      * −10\n      * −09:30\n      * −9\n      * −8\n      * -7\n      * -6\n      * -5\n      * -4\n      * −03:30\n      * -3\n      * -2\n      * -1\n      * +0\n      * +1\n      * +2\n      * +3\n      * +03:30\n      * +4\n      * +04:30\n      * +5\n      * +05:30\n      * +05:45\n      * +6\n      * +06:30\n      * +7\n      * +8\n      * +08:45\n      * +9\n      * +09:45\n      * +10\n      * +10:30\n      * +11\n      * +12\n      * +12:45\n      * +13\n      * +14\n*  Language: ISO 639-1 standard. E.g. 'en', 'es' etc.\n*  Country: ISO 3166-1 alpha-2 standard. E.g. 'GB', 'US' etc.\n\n### Workflow steps\nThe workflow steps define what happens after a workflow is activated as a graph of nodes. All nodes share a set of common attributes:\n* name - gives a user friendly name to a node\n* description - useful for putting a note about the role of a specific node in the scenario\n* type - indicates the type of the node\n* transitions - From each node there's one or more labeled transitions to other nodes within the same scenario definition. This captures this\n  information, like a list of pairs of the form (label, node names) \n\nThe node type must always be defined, and can be one of the following:\n* START - Start nodes are a special type of nodes that indicate the starting point of a workflow. There's only one START node per workflow definition and it has the special and reserved name 'START'.\n* TERMINAL - This node type indicates that the workflow ends at this point, they act like terminal points in the graph stopping any further traversing of the graph of nodes. There can be many TERMINAL \n  nodes per workflow definition and they can have custom names.\n* ACTION - This node type represents a webhook action, i.e. that a URL should be invoked as a result of the workflow reaching this step.\n* WAIT - Represents an unconditional wait action for a specified amount of time.\n* CONDITION - A condition node acts as a decision point to determine which path the workflow will follow out of multiple alternatives. \n* WAIT_ON_CONDITION - A condition that is evaluated multiple times within a given time limit. If at any time the condition becomes true, \n  then the flow continues along the TRUE transition. Otherwise, if the time limit is passed and the condition is still false, then the FALSE transition is taken.\n* SENDGRID_EMAIL_ACTION - Action for sending an email through SendGrid.\n* MANDRILL_EMAIL_ACTION - Action for sending an email through Mandrill.\n* SNS_PUSH_ACTION - Action for sending Push notifications using Amazon SNS\n Distinct node types require specific properties to define their actions. All these are defined in the workflow types below.\n* ADWORDS_REMARKETING_ACTION - An action that adds the user to a Google Adwords remarketing user list.\n* TAG - Action that adds a tag to the user, can be used for segmentation or conditions later on.\n* UNTAG - Action that removes a tag from the user\n\nMultiple action parameters can include dynamic content by using a notation such as ${user.Email}. Currently three types of dynamic content are supported:\n* ${user.userAttribute} is replaced by the value of the user attribute\n* ${event.eventAttribute} is replaced by the value of the event attribute\n* ${translation.translationId[key][alt]} is replaced by looking up the 'alt' alternative of key 'key' in translation resource with ID 'translationId'. \nFor instance,  ${translation.10121[WELCOME_MSG][EN]} will be replaced with the 'EN' alternative of the key 'WELCOME_MSG' from resource 10121. The ${} \nnotation can be nested. Therefore ${translation.10121[WELCOME_MSG][${user.language}]} will be replaced according to the value in the 'language' user attribute.\n\n      \nEach type of node has a set of predefined outgoing transitions as follows:\n  \n* START\n  * OK - The 'OK' transition will be followed unconditionally when encountering a START step. \n* TERMINAL: No outgoing transitions are considered when reaching a TERMINAL. Instead the workflow is marked as completed at that point.\n* ACTION \n  * OK - Followed when the webhook call has been completed successfully\n  * ERROR - Followed in case the call couldn't be made or we received a 5xx response code\n* WAIT\n  * TIMEOUT - Followed when the requested delay has been reached.\n* CONDITION \n  * TRUE - Followed when the condition evaluates to TRUE\n  * FALSE - Followed when the condition evaluates to FALSE\n  * TIMEOUT - For conditions with a timeout setting, this will be followed when the requested delay has been reached.\n\n \nTo put everything together here is an example workflow definition in JSON:\n ```\n    {\n        \"name\": \"Example Email Workflow\",\n        \"applicationId\": 10000,\n        \"version\": {\n          \"id\": 12345,\n          \"name\": \"Welcome Flow\",\n          \"status\": \"ACTIVE\",\n          \"triggerExpression\": \"event.EventType == 'DemoEmailSend'\",\n          \"steps\": [\n             {\n                  \"id\": \"START\",\n                  \"name\": \"Start\",\n                  \"type\": \"START\",\n                  \"transitions\": {\n                      \"OK\": \"SEND_EMAIL\",\n                      \"ERROR\": \"FIN\"\n                  }\n              },\n              {\n                  \"id\" : \"SEND_EMAIL\",\n                  \"name\": \"WELCOME_EMAIL\",\n                  \"type\": \"SENDGRID_EMAIL_ACTION\",\n                  \"transitions\": {\n                      \"OK\": \"FIN\",\n                      \"ERROR\": \"FIN_ERR\"\n                  },\n                  \"templateId\": \"sendGrid ID\",\n                  \"emailTo\": \"${user.Email}\",\n                  \"emailToName\": \"${user.FirstName}\",\n                  \"replyTo\": \"your@email.com\",\n                  \"replyToName\": \"Your Name\",\n                  \"from\": \"your@email.com\",\n                  \"fromName\": \"DataTiger\",\n                  \"subject\": \"Welcome to DataTiger\",\n                  \"trackOpen\": true,\n                  \"trackClick\": true,\n                  \"substitutions\": [\n                      {\n                          \"token\": \"%firstName%\",\n                          \"value\": \"${user.FirstName}\"\n                      }\n                  ],\n                  \"sandboxed\": false\n              },\n              {\n                  \"id\": \"FIN\",\n                  \"name\": \"FIN\",\n                  \"type\": \"TERMINAL\"\n              },\n              {\n                  \"id\": \"FIN_ERR\",\n                  \"name\": \"FIN_ERR\",\n                  \"type\": \"TERMINAL\"\n              }\n          ]\n      }\n    }\n```     \n \n\n## Spreadsheets\nThe content of multicopy/multilanguage actions is specified in external 'content sources'. Here is an example of the supported content: https://docs.google.com/spreadsheets/d/1UMz7VSfe27JvGy0Lx8hWp4IhEZz-t9tW5KLKx3FbnME\n\nCurrently, only google spreadsheets with public links are supported (it's important to set the spreadsheet sharing to public, where everyone with the link can view it) \n\nThe spreadsheets can be used in the system by first adding them using the 'translations/' API. Each entry will refer to exactly one\nsheet (tab) within a spreadsheet.\n\nThe general concept is that they associate keys with content.\n\nThe supported features are:\n* content translation\n* action properties pre-population\n* random content variations\n* dynamic content variations (as opposed to random, the variation is choosen using a user/event property value)\n\nThe structure of the spreadsheet is as follows:\n* The 1st row is reserved for headers understood by datatiger\n* The leftmost column, or the one with the special header \"$key\", contains keys that identify the content. If a row has no key, the row is ignored.\n* 1st row headers that do not start with '$' are considered to be languages (e.g 'EN', 'ES', 'GR' etc)\n* $default should be the header of all content when there are no language translations (either $default or language headers are allowed, but not both)\n* $randomVariation column, if specified, allows multiple values for the same key. One of them will be selected at random for each action execution\n* $propertyVariation column, if specified, also allows multiple values for the same key. The variation that exactly matches a user/event property specified in the action step.\n* $fieldType allows auto-filling of actions. At the moment it is supported (and required) for SNS Push actions. It specifies the action field to which the content corresponds. Allowed values are:\n  * androidTitle\n  * androidMessage\n  * androidImage\n  * androidVideo\n  * iosTitle\n  * iosMessage\n  * iosImage\n  * iosVideo\n* $templateType is required for SNS Push actions and should specify the type of template to use. Available values are:\n  * TEXT\n  * TEXT_WITH_TITLE\n  * TEXT_WITH_IMAGE\n  * TEXT_WITH_TITLE_AND_IMAGE(\n  * TEXT_WITH_VIDEO\n  * TEXT_WITH_TITLE_AND_VIDEO\n* Multiple consistency checks are performed when the spreadsheets are loaded, but generally they should be both internally consistent and consistent with the actions they are used for.\n  \n",
    "version": "1.0.0"
  },
  "host": "api.datatiger.com",
  "basePath": "/",
  "schemes": [
    "https"
  ],
  "tags": [
    {
      "name": "authentication",
      "description": "System health and reporting"
    },
    {
      "name": "health",
      "description": "System health and reporting"
    },
    {
      "name": "datatypes",
      "description": "Supported data types, event and user schema"
    },
    {
      "name": "users",
      "description": "Management of users"
    },
    {
      "name": "applications",
      "description": "Management of applications"
    },
    {
      "name": "settings",
      "description": "Management of settin gs"
    },
    {
      "name": "abtests",
      "description": "Management of AB tests"
    },
    {
      "name": "tags",
      "description": "Management of tags"
    },
    {
      "name": "segments",
      "description": "Management of segments"
    },
    {
      "name": "workflows",
      "description": "Management of workflows"
    },
    {
      "name": "reporting",
      "description": "Reporting on workflows executions"
    },
    {
      "name": "translations",
      "description": "Management of translation resources"
    },
    {
      "name": "oauth",
      "description": "OAuth endpoints"
    },
    {
      "name": "stepdata",
      "description": "Workflow step data"
    },
    {
      "name": "dev",
      "description": "Integration tools for developers"
    },
    {
      "name": "proxy",
      "description": "Proxy services for use by frontend environments"
    },
    {
      "name": "privacy",
      "description": "User privacy related requests"
    }
  ],
  "x-tagGroups": [
    {
      "name": "System calls",
      "tags": [
        "proxy",
        "health",
        "authentication",
        "settings",
        "users",
        "oauth"
      ]
    },
    {
      "name": "User journey management",
      "tags": [
        "applications",
        "translations",
        "workflows",
        "abtests",
        "tags",
        "segments",
        "reporting",
        "stepdata"
      ]
    },
    {
      "name": "Data types",
      "tags": [
        "datatypes"
      ]
    },
    {
      "name": "Developer Tools",
      "tags": [
        "dev"
      ]
    },
    {
      "name": "Privacy",
      "tags": [
        "gdpr"
      ]
    }
  ],
  "paths": {
    "/proxy/sendgridTemplates": {
      "get": {
        "summary": "Returns a list of the sendgrid templates according to the sendgrid settings under the user's client account.",
        "description": "Returns a list of the sendgrid templates according to the sendgrid settings under the user's client account.\nThe response is exactly the same as that of sendgrid\n",
        "tags": [
          "proxy"
        ],
        "operationId": "getSendgridTemplates",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The sendgrid templates"
          },
          "401": {
            "description": "User authetnication failed",
            "schema": {
              "$ref": "#/definitions/GetEventsResponse"
            }
          },
          "403": {
            "description": "Sendgrid authetnication failed",
            "schema": {
              "$ref": "#/definitions/GetEventsResponse"
            }
          }
        }
      }
    },
    "/proxy/mandrillTemplates": {
      "get": {
        "summary": "Returns a list of the mandrill templates according to the mandrill settings under the user's client account.",
        "description": "Returns a list of the mandrill templates according to the mandrill settings under the user's client account.\nThe response is exactly the same as that of mandrill\n",
        "tags": [
          "proxy"
        ],
        "operationId": "getMandrilTemplates",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The mandrill templates"
          },
          "401": {
            "description": "User authetnication failed",
            "schema": {
              "$ref": "#/definitions/GetEventsResponse"
            }
          },
          "403": {
            "description": "Mandrill authetnication failed",
            "schema": {
              "$ref": "#/definitions/GetEventsResponse"
            }
          }
        }
      }
    },
    "/dev/events": {
      "get": {
        "summary": "returns a list of events that were received for a specific user within a given date range",
        "description": "This endpoint allows you to retrieve the events that were captured for a specific user and within\na given date range. A user is identified by the application identifier and the user identifier. You can also\nsearch for only specific type of event using the query parameter eventType. \nThere is a restriction on the number of days that your input date range can span which at the moment is set to 7 days.\n",
        "tags": [
          "dev"
        ],
        "operationId": "getEvents",
        "parameters": [
          {
            "$ref": "#/parameters/getEventsUserIdFilter"
          },
          {
            "$ref": "#/parameters/getEventsAppIdFilter"
          },
          {
            "$ref": "#/parameters/getEventsEventTypeFilter"
          },
          {
            "$ref": "#/parameters/getEventsStartTimeFilter"
          },
          {
            "$ref": "#/parameters/getEventsEndTimeFilter"
          },
          {
            "$ref": "#/parameters/getEventsMaxResultsFilter"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "A JSON document that contains the list of events that were found for that user and matching the search criteria.\nThe list is ordered by the creation date of the events in descending order, i.e. the most recent events appear first.            \n",
            "schema": {
              "$ref": "#/definitions/GetEventsResponse"
            }
          },
          "401": {
            "description": "the request was rejected because it concerned an application identifier that doesn't exist in this account.\n"
          }
        }
      }
    },
    "/dev/applications/{application}/users/{userId}": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/getUserPropertiesUserIdParam"
        }
      ],
      "get": {
        "summary": "returns the properties of a specific user within the context of a specific application",
        "description": "This endpoint will return a JSON document containing the properties of the user identified\nby the specified user ID. as different applications can have distinct user identifiers,the application identifier\nis also required at the path level.\n",
        "tags": [
          "dev"
        ],
        "operationId": "getUserProperties",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "A JSON document containing the properties of the specified user."
          },
          "400": {
            "description": "The application or the specified user does not exist."
          },
          "500": {
            "description": "An internal error has occurred"
          }
        }
      }
    },
    "/dev/events/validate": {
      "post": {
        "summary": "Validates the input event returning a list of validation errors in the case of error.",
        "description": "Use this endpoint to check whether an event would have been accepted by the system. In case the event \nis classified as invalid, the response contains information to pinpoint the exact cause of the validation failure.\n",
        "tags": [
          "dev"
        ],
        "operationId": "validateEvent",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The event has passed the validation check successfully. The response will be empty in this case."
          },
          "400": {
            "description": "The event has failed the validation, the response will contain a description of the validation errors.\n",
            "schema": {
              "$ref": "#/definitions/ValidateEventResponse"
            }
          }
        }
      }
    },
    "/dev/events/record": {
      "post": {
        "summary": "Validates the input event and passes the event downstream for further processing",
        "description": "Validates the input event and if the validation is successfull it then writes the event into the event stream.\n",
        "tags": [
          "dev"
        ],
        "operationId": "validateAndRecordEvent",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The event has passed the validation check successfully and was pushed into the events stream. The response will be empty in this case."
          },
          "400": {
            "description": "The event has failed the validation, the response will contain a description of the validation errors.\n",
            "schema": {
              "$ref": "#/definitions/ValidateEventResponse"
            }
          }
        }
      }
    },
    "/data/types": {
      "get": {
        "summary": "Lists the available data types and operators",
        "description": "Returns a list of all the supported data types and the list of operators that can be\napplied on that data type.\n",
        "tags": [
          "datatypes"
        ],
        "operationId": "getDataTypes",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Returns the list of data types and their applicable operators",
            "schema": {
              "$ref": "#/definitions/OperatorType"
            }
          }
        }
      }
    },
    "/data/user": {
      "get": {
        "summary": "Lists the available user attributes",
        "description": "Lists the name and type of each attribute defined at the user level. This information\nis necessary to know which attributes can be included in workflow condition expressions when using the User dimension.\nEach attribute is identified by a name and a data type. \n",
        "tags": [
          "datatypes"
        ],
        "operationId": "getUserDataDictionary",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Lists the name and type of each attribute defined at the user level.",
            "schema": {
              "$ref": "#/definitions/UserDataDictionaryType"
            }
          }
        }
      },
      "put": {
        "summary": "Updates the list of user attributes",
        "description": "Submits a new version of the available user attributes replacing the previous one.\n",
        "tags": [
          "datatypes"
        ],
        "operationId": "updateUserDataDictionary",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "data",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UserDataDictionaryType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the original user attributes list that was used as an input to this operation.",
            "schema": {
              "$ref": "#/definitions/UserDataDictionaryUpdateResponse"
            }
          }
        }
      }
    },
    "/data/events": {
      "get": {
        "summary": "Lists the available event attributes",
        "description": "Lists the name and type of each attribute defined at the user and event level. This information\nis necessary to know which attributes can be included in workflow condition expressions when using the Event dimension.\nEach attribute is identified by a name and a data type.\n",
        "tags": [
          "datatypes"
        ],
        "operationId": "getEventsDataDictionary",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Lists the name and type of each attribute defined at the user and event level.",
            "schema": {
              "$ref": "#/definitions/EventsDataDictionaryType"
            }
          }
        }
      },
      "put": {
        "summary": "Updates the list of event attributes and event types",
        "description": "Submits a new version of the available event attributes and event types replacing the previous one.\n",
        "tags": [
          "datatypes"
        ],
        "operationId": "updateEventsDataDictionary",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "data",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/EventsDataDictionaryType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Returns the original user attributes list that was used as an input to this operation.\nIf the changes introduce breaking changes then the operation will fail and a list of validation errors will be returned in the field validationErrors.\n",
            "schema": {
              "$ref": "#/definitions/EventsDataDictionaryUpdateResponse"
            }
          }
        }
      }
    },
    "/ping": {
      "get": {
        "summary": "Checks if the server is running",
        "description": "If the server is up and running the JSON string \"pong\" is returned.  \n",
        "tags": [
          "health"
        ],
        "operationId": "ping",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "If the server is up and running the string \"pong\" is returned (including the double quotes)",
            "schema": {
              "type": "string"
            }
          }
        }
      }
    },
    "/account/login": {
      "post": {
        "summary": "Authenticates an HTTP session using the user credentials (username/password). This can be used as an alternative to the API token authentication.",
        "description": "Authenticates the user using a pair of username and password.    \n",
        "tags": [
          "authentication"
        ],
        "operationId": "login",
        "produces": [
          "text/plain"
        ],
        "consumes": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/LoginRequestType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Authentication was successful.",
            "schema": {
              "type": "string"
            }
          },
          "401": {
            "description": "Unauthorized. Username does not exist or username/password combination is invalid.",
            "schema": {
              "type": "string"
            }
          }
        }
      }
    },
    "/account/logout": {
      "post": {
        "summary": "Logs out the current user.",
        "description": "Logs out the current user by invalidating the current session    \n",
        "tags": [
          "authentication"
        ],
        "operationId": "logout",
        "produces": [
          "text/plain"
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "responses": {
          "200": {
            "description": "Logout was successfull.",
            "schema": {
              "type": "string"
            }
          },
          "400": {
            "description": "Bad request. Potentially there is no valid autheticated session",
            "schema": {
              "type": "string"
            }
          }
        }
      }
    },
    "/clientaccounts/{clientAccount}": {
      "parameters": [
        {
          "$ref": "#/parameters/clientAccountParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "put": {
        "summary": "Updates a client account.",
        "description": "Updates the client wide settings.\n",
        "tags": [
          "settings"
        ],
        "operationId": "updateClientAccount",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ClientAccountTypeForUpdate"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The client account was updated successfully",
            "schema": {
              "$ref": "#/definitions/ClientAccountTypePopulated"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "get": {
        "summary": "Get information about a client account",
        "description": "Return all the client wide settings of the requested client account\n",
        "tags": [
          "settings"
        ],
        "operationId": "getClientAccount",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The client account",
            "schema": {
              "$ref": "#/definitions/ClientAccountTypePopulated"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The client account with the specified identifier does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "500": {
            "description": "The update failed due to internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/useraccounts": {
      "parameters": [
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get users of the client account.",
        "description": "List all the users of the client according to the (optionally) specified filters. \n",
        "tags": [
          "users"
        ],
        "operationId": "getUsers",
        "parameters": [
          {
            "$ref": "#/parameters/IdFilter"
          },
          {
            "$ref": "#/parameters/usernameFilter"
          },
          {
            "$ref": "#/parameters/emailFilter"
          },
          {
            "$ref": "#/parameters/firstNameFilter"
          },
          {
            "$ref": "#/parameters/lastNameFilter"
          },
          {
            "$ref": "#/parameters/pagingPageParam"
          },
          {
            "$ref": "#/parameters/pagingPerPageParam"
          },
          {
            "$ref": "#/parameters/clientAccountIdParam"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The set of user accounts that match the filter criteria",
            "schema": {
              "type": "object",
              "properties": {
                "paging": {
                  "$ref": "#/definitions/PagingType"
                },
                "items": {
                  "description": "Array of the returned applications",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/UserAccountType"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "post": {
        "summary": "Creates a new user account",
        "description": "Creates a new user account, under the same client account that the current user belongs. Only users with appropriate permissions can create new user accounts. \n",
        "tags": [
          "users"
        ],
        "operationId": "createUserAccount",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/clientAccountIdParam"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateUserAccountType"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The user was created succesfully",
            "schema": {
              "$ref": "#/definitions/UserAccountType"
            },
            "headers": {
              "Location": {
                "description": "The location of the created user account",
                "type": "string"
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "403": {
            "description": "User is not allowed to create a new user account.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/useraccounts/{useraccountid}": {
      "parameters": [
        {
          "$ref": "#/parameters/useraccountparam"
        },
        {
          "$ref": "#/parameters/authParam"
        },
        {
          "$ref": "#/parameters/clientAccountIdParam"
        }
      ],
      "put": {
        "summary": "Updates an user account",
        "description": "Updates the information of an existing user account. Users can modify their own properties. Only users with the appropriate permissions can modify other users' properties. \n",
        "tags": [
          "users"
        ],
        "operationId": "updateUserAccount",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UpdateUserAccountType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The user was updated successfully",
            "schema": {
              "$ref": "#/definitions/UserAccountType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "403": {
            "description": "User does not have permission to update the target user account.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "delete": {
        "summary": "Deletes a user account. Only users with adequate permissions can delete user accounts.",
        "description": "Deletes a user account\n",
        "tags": [
          "users"
        ],
        "operationId": "deleteUserAccount",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "test/plain"
        ],
        "responses": {
          "204": {
            "description": "The account was deleted succesfully",
            "schema": {
              "type": "string"
            }
          },
          "404": {
            "description": "The account was not found",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "get": {
        "summary": "Get a user account",
        "description": "Returns the identified user account\n",
        "tags": [
          "users"
        ],
        "operationId": "getUserAccount",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The user account",
            "schema": {
              "$ref": "#/definitions/UserAccountType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The user account with the specified identifier does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "500": {
            "description": "The update failed due to internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/useraccounts/{useraccountid}/credentials": {
      "parameters": [
        {
          "$ref": "#/parameters/useraccountparam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "post": {
        "summary": "Update the security credentials of a user account",
        "description": "Update the security credentials of a user account",
        "tags": [
          "users"
        ],
        "operationId": "updateUserCredentials",
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ChangePasswordRequestType"
            }
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The user account"
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "403": {
            "description": "User does not have permission to update the target user account credentials, or the old password is wrong.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The user account with the specified identifier does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "500": {
            "description": "The update failed due to internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications": {
      "parameters": [
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get applications",
        "description": "List all the applications \n",
        "tags": [
          "applications"
        ],
        "operationId": "getApplications",
        "parameters": [
          {
            "$ref": "#/parameters/nameFilter"
          },
          {
            "$ref": "#/parameters/IdFilter"
          },
          {
            "$ref": "#/parameters/pagingPageParam"
          },
          {
            "$ref": "#/parameters/pagingPerPageParam"
          },
          {
            "$ref": "#/parameters/ApplicationSortingParam"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The set of applications that match the filter criteria",
            "schema": {
              "type": "object",
              "properties": {
                "paging": {
                  "$ref": "#/definitions/PagingType"
                },
                "items": {
                  "description": "Array of the returned applications",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/ApplicationType"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "post": {
        "summary": "Creates a new application",
        "description": "Creates a new application. \n",
        "tags": [
          "applications"
        ],
        "operationId": "createApplication",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateApplicationType"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The application was created successfully",
            "schema": {
              "$ref": "#/definitions/ApplicationType"
            },
            "headers": {
              "Location": {
                "description": "The location of the created item",
                "type": "string"
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "put": {
        "summary": "Updates an application",
        "description": "Updates an application by overriding the existing entry.\n",
        "tags": [
          "applications"
        ],
        "operationId": "updateApplication",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/ApplicationType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The application was updated successfully",
            "schema": {
              "$ref": "#/definitions/ApplicationType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "get": {
        "summary": "Get an application",
        "description": "Return the identified application\n",
        "tags": [
          "applications"
        ],
        "operationId": "getApplication",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The application",
            "schema": {
              "$ref": "#/definitions/ApplicationType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application with the specified identifier does not exist.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "500": {
            "description": "The update failed due to internal server error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/translations": {
      "parameters": [
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get translation resources",
        "description": "List all translation resources, according to an optional set of filters. \n",
        "tags": [
          "translations"
        ],
        "operationId": "getTranslations",
        "parameters": [
          {
            "$ref": "#/parameters/nameFilter"
          },
          {
            "$ref": "#/parameters/urlFilter"
          },
          {
            "$ref": "#/parameters/pagingPageParam"
          },
          {
            "$ref": "#/parameters/pagingPerPageParam"
          },
          {
            "$ref": "#/parameters/TranslationSortingParam"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The set of translation resources that match",
            "schema": {
              "type": "object",
              "properties": {
                "paging": {
                  "$ref": "#/definitions/PagingType"
                },
                "items": {
                  "description": "Array of the returned translation resources",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/PopulatedTranslationResourceType"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "post": {
        "summary": "Creates a translation resource",
        "description": "Creates a new translation resource \n",
        "tags": [
          "translations"
        ],
        "operationId": "creatTranslation",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateTranslationResourceType"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The translation resource was created successfully",
            "schema": {
              "$ref": "#/definitions/PopulatedTranslationResourceType"
            },
            "headers": {
              "Location": {
                "description": "The location of the created item",
                "type": "string"
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/translations/{translationId}": {
      "parameters": [
        {
          "$ref": "#/parameters/translationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get a translation resource",
        "description": "Return the identified translation resource\n",
        "tags": [
          "translations"
        ],
        "operationId": "getTranslation",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The translation resource",
            "schema": {
              "$ref": "#/definitions/PopulatedTranslationResourceType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The specified translation resource couldn't be found",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "put": {
        "summary": "Updates an translation resource",
        "description": "Updates a translation resource by overriding the existing entry.\n",
        "tags": [
          "translations"
        ],
        "operationId": "updateTranslationResource",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UpdateTranslationResourceType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The entity was updates successfully",
            "schema": {
              "$ref": "#/definitions/PopulatedTranslationResourceType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "delete": {
        "summary": "Deletes a translation resource",
        "description": "Deletes a translation resource\n",
        "tags": [
          "translations"
        ],
        "operationId": "deleteTranslationResource",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "text/plain"
        ],
        "responses": {
          "204": {
            "description": "The translation resource was deleted succesfully",
            "schema": {
              "type": "string"
            }
          },
          "404": {
            "description": "The translation resource was not found",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/ext/googlesheets/sheets": {
      "parameters": [
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get the list of sheets in a google spreadsheet",
        "description": "Get the list of sheets in a google spreadsheet \n",
        "tags": [
          "translations"
        ],
        "operationId": "getGoogleSpreadSheetSheets",
        "parameters": [
          {
            "$ref": "#/parameters/url"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "A list of the available sheets",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/abtests": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get the AB tests of an application",
        "description": "List the AB tests of an application\n",
        "tags": [
          "abtests"
        ],
        "operationId": "getABTestsOfApplication",
        "parameters": [
          {
            "$ref": "#/parameters/nameFilter"
          },
          {
            "$ref": "#/parameters/pagingPageParam"
          },
          {
            "$ref": "#/parameters/pagingPerPageParam"
          },
          {
            "$ref": "#/parameters/ABTestsSortingParam"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The set of AB tests that match the filter criteria",
            "schema": {
              "type": "object",
              "properties": {
                "paging": {
                  "$ref": "#/definitions/PagingType"
                },
                "items": {
                  "description": "Array of the returned applications",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/ABTestType"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "post": {
        "summary": "Creates a new AB test",
        "description": "Creates a new AB test under the specified application\n",
        "tags": [
          "abtests"
        ],
        "operationId": "createABTestInApplication",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateABTestType"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The AB test was created successfully",
            "schema": {
              "$ref": "#/definitions/ABTestType"
            },
            "headers": {
              "Location": {
                "description": "The location of the created item",
                "type": "string"
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/abtests/{abTest}": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/abTestParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get an AB test",
        "description": "Return an AB test, identified by the AB test ID\n",
        "tags": [
          "abtests"
        ],
        "operationId": "getABTestOfApplication",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The AB test",
            "schema": {
              "$ref": "#/definitions/ABTestType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The workflow does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "put": {
        "summary": "Updates an ABTest",
        "description": "Updates an ABTest\n",
        "tags": [
          "abtests"
        ],
        "operationId": "update",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateABTestType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The AB test was updated successfully",
            "schema": {
              "$ref": "#/definitions/ABTestType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/segments": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get all available segments for that application",
        "tags": [
          "segments"
        ],
        "operationId": "getSegments",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The segments",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/SegmentType"
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "post": {
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SegmentType"
            }
          }
        ],
        "summary": "Create a new segment for that application",
        "tags": [
          "segments"
        ],
        "operationId": "newSegment",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The segment with the assigned id",
            "schema": {
              "$ref": "#/definitions/SegmentType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/segments/{segmentId}": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        },
        {
          "$ref": "#/parameters/segmentParam"
        }
      ],
      "get": {
        "summary": "Get a specific segment",
        "tags": [
          "segments"
        ],
        "operationId": "getSegment",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The segment",
            "schema": {
              "$ref": "#/definitions/SegmentType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "delete": {
        "summary": "delete a specific segment",
        "tags": [
          "segments"
        ],
        "operationId": "deleteSegment",
        "responses": {
          "200": {
            "description": "The segment got deleted"
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "put": {
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/SegmentType"
            }
          }
        ],
        "summary": "Update segment for that application",
        "tags": [
          "segments"
        ],
        "operationId": "updateSegment",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The updated segment",
            "schema": {
              "$ref": "#/definitions/SegmentType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/tags/{tagId}": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/tagParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get a Tag",
        "description": "Return a tag, identified by the tag ID\n",
        "tags": [
          "tags"
        ],
        "operationId": "getTag",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The tag",
            "schema": {
              "$ref": "#/definitions/TagType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application or tag does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "delete": {
        "summary": "Deletes a tag",
        "description": "Deletes a tag\n",
        "tags": [
          "tags"
        ],
        "operationId": "delete",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The tag was deleted successfully"
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/tags/": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Get all tags associated with the application",
        "tags": [
          "tags"
        ],
        "operationId": "getTagsOfApplication",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The tags associated with the application",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/TagType"
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application or tag does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "post": {
        "summary": "Create a new tag",
        "tags": [
          "tags"
        ],
        "operationId": "createTag",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/TagType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The tags with the assigned Id",
            "schema": {
              "$ref": "#/definitions/TagType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The application or tag does not exist",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/pushTemplates": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Lists all push templates of an application",
        "description": "Lists all push templates of an application\n",
        "tags": [
          "settings"
        ],
        "operationId": "getPushTempaltesOfApplication",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The set of available push templates of this application.",
            "schema": {
              "type": "object",
              "properties": {
                "paging": {
                  "$ref": "#/definitions/PagingType"
                },
                "items": {
                  "description": "Array of the push notification templates",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/PushTemplateType"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Lists the workflows of the application",
        "description": "Lists the default versions of all workflows under the specified application that match the filtering criteria\nspecified in the parameters.\n",
        "tags": [
          "workflows"
        ],
        "operationId": "getWorkflowsOfApplication",
        "parameters": [
          {
            "$ref": "#/parameters/nameFilter"
          },
          {
            "$ref": "#/parameters/statusFilter"
          },
          {
            "$ref": "#/parameters/dateFromFilter"
          },
          {
            "$ref": "#/parameters/dateToFilter"
          },
          {
            "$ref": "#/parameters/pagingPageParam"
          },
          {
            "$ref": "#/parameters/pagingPerPageParam"
          },
          {
            "$ref": "#/parameters/WorkflowSortingParam"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The set of workflows that match the filtering criteria.",
            "schema": {
              "type": "object",
              "properties": {
                "paging": {
                  "$ref": "#/definitions/PagingType"
                },
                "items": {
                  "description": "Array of the returned applications",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/WorkflowType"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "post": {
        "summary": "Creates a new workflow",
        "description": "Creates a new workflow version under the specified application.\n",
        "tags": [
          "workflows"
        ],
        "operationId": "createWorkflow",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateWorkflowType"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "The workflow was created successfully",
            "schema": {
              "$ref": "#/definitions/WorkflowType"
            },
            "headers": {
              "Location": {
                "description": "The location of the created item",
                "type": "string"
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/status": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Returns status of last executions of scheduled campaigns for the specified application",
        "tags": [
          "workflows"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Most recent statuses of the workflow versions assigned to",
            "schema": {
              "$ref": "#/definitions/WorkflowExecutionStatus"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}/versions/{version}/status": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/workflowParam"
        },
        {
          "$ref": "#/parameters/versionParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Returns status of last scheduled executions of the specified workflow version",
        "tags": [
          "workflows"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Most recent statuses of the workflow versions assigned to",
            "schema": {
              "$ref": "#/definitions/WorkflowExecutionStatus"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/actions/validate": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        }
      ],
      "post": {
        "summary": "Validates a new workflow.",
        "description": "Validates a new workflow without performing any modifications to the database.\n",
        "tags": [
          "workflows"
        ],
        "operationId": "validateWorkflowOfApplications",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/CreateWorkflowType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The workflow is valid",
            "schema": {
              "$ref": "#/definitions/WorkflowType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "409": {
            "description": "Conflict",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}/versions": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/workflowParam"
        },
        {
          "$ref": "#/parameters/authParam"
        },
        {
          "$ref": "#/parameters/nameFilter"
        },
        {
          "$ref": "#/parameters/statusFilter"
        }
      ],
      "get": {
        "summary": "Gets all the versions of a specific workflow",
        "description": "Gets all the versions of a specific workflow\n",
        "tags": [
          "workflows"
        ],
        "operationId": "getAllWorkflowVersions",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The set of workflows that match the filtering criteria.",
            "schema": {
              "type": "object",
              "properties": {
                "paging": {
                  "$ref": "#/definitions/PagingType"
                },
                "items": {
                  "description": "Array of the returned applications",
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/WorkflowType"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The workflow with the specified identifier was not found",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}/versions/{version}": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/workflowParam"
        },
        {
          "$ref": "#/parameters/versionParam"
        },
        {
          "$ref": "#/parameters/authParam"
        }
      ],
      "get": {
        "summary": "Gets a specific version of a workflow",
        "description": "Gets a specific version of a workflow\n",
        "tags": [
          "workflows"
        ],
        "operationId": "getWorkflowVersion",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The workflow",
            "schema": {
              "$ref": "#/definitions/WorkflowType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The workflow with the specified identifier was not found",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "put": {
        "summary": "Updates a workflow version.",
        "description": "Updates a workflow version. \n",
        "tags": [
          "workflows"
        ],
        "operationId": "updateWorkflowVersion",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The workflow was updated successfully",
            "schema": {
              "$ref": "#/definitions/WorkflowType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "delete": {
        "summary": "Deletes a workflow version.",
        "description": "Deletes an existing workflow. If a workflow is deleted while currently active for a user, it will be executed as normal.\n",
        "tags": [
          "workflows"
        ],
        "operationId": "deleteWorkflowVersion",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "test/plain"
        ],
        "responses": {
          "204": {
            "description": "The workflow version was deleted succesfully",
            "schema": {
              "type": "string"
            }
          },
          "404": {
            "description": "The workflow version was not found",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}": {
      "parameters": [
        {
          "$ref": "#/parameters/applicationParam"
        },
        {
          "$ref": "#/parameters/workflowParam"
        }
      ],
      "get": {
        "summary": "Gets the default version of a specific workflow",
        "description": "Return an application workflow, identified by the workflow ID\n",
        "tags": [
          "workflows"
        ],
        "operationId": "getWorkflowOfApplication",
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The workflow",
            "schema": {
              "$ref": "#/definitions/WorkflowType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "404": {
            "description": "The workflow with the specified identifier was not found",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "put": {
        "summary": "Updates the non-versioned properties of a workflow.",
        "description": "Updates the non-versioned properties of a workflow.\n",
        "tags": [
          "workflows"
        ],
        "operationId": "updateWorkflowProperties",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/UpdateWorkflowType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The workflow was updated successfully",
            "schema": {
              "$ref": "#/definitions/WorkflowType"
            }
          },
          "400": {
            "description": "Malformed request",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      },
      "delete": {
        "summary": "Deletes a workflow.",
        "description": "Deletes an existing workflow. If a workflow is deleted while currently active for a user, it will be executed as normal.\n",
        "tags": [
          "workflows"
        ],
        "operationId": "deleteWorkflow",
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "test/plain"
        ],
        "responses": {
          "204": {
            "description": "The workflow was deleted succesfully",
            "schema": {
              "type": "string"
            }
          },
          "404": {
            "description": "The workflow was not found",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "default": {
            "description": "Unexpected error",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/preview_action": {
      "post": {
        "summary": "Executes the defined workflowstep with the specified user/event attributes",
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/applicationParam"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/PreviewRequestType"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The action was executed correctly",
            "schema": {
              "$ref": "#/definitions/PreviewResultType"
            }
          },
          "400": {
            "description": "Invalid parameters",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "500": {
            "description": "The action did not execute correctly",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "503": {
            "description": "The actions handler load balancer is unavailable"
          }
        },
        "tags": [
          "workflows"
        ]
      }
    },
    "/applications/{application}/workflows/{workflow}/versions/{version}/reporting": {
      "get": {
        "summary": "Returns the number of executions of each step of a given workflow and time period",
        "description": "List the number of executions per workflow step for a specified time period\n",
        "tags": [
          "reporting"
        ],
        "operationId": "reportWorkflow",
        "parameters": [
          {
            "$ref": "#/parameters/applicationParam"
          },
          {
            "$ref": "#/parameters/workflowParam"
          },
          {
            "$ref": "#/parameters/versionParam"
          },
          {
            "$ref": "#/parameters/reportingFromFilter"
          },
          {
            "$ref": "#/parameters/reportingUntilFilter"
          },
          {
            "$ref": "#/parameters/reportingAggregationFilter"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Upon success the response will contain the initial request parameters under the request key while the groups key will contain the table of execution counts per time unit",
            "schema": {
              "$ref": "#/definitions/ReportingResponseType"
            }
          },
          "400": {
            "description": "For client errors, the code indicates what was wrong about the request alongside an optinal message with a human readable explanation of what went wrong.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}/versions/{version}/analytics": {
      "get": {
        "summary": "Returns uplift analytics for the workflow version, using the most recent sample of data.",
        "description": "Returns uplift analytics for the workflow version\n",
        "tags": [
          "reporting"
        ],
        "operationId": "reportWorkflowAnalytics",
        "parameters": [
          {
            "$ref": "#/parameters/applicationParam"
          },
          {
            "$ref": "#/parameters/workflowParam"
          },
          {
            "$ref": "#/parameters/versionParam"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Most recent workflow version analytics.",
            "schema": {
              "$ref": "#/definitions/AnalyticsReportingResponseType"
            }
          },
          "404": {
            "description": "The reference workflow/version could not be found.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}/analytics/reporting": {
      "get": {
        "summary": "Returns metrics for the workflow for a specified period.",
        "description": "Returns metrics for the workflow for a specified period.\n",
        "tags": [
          "reporting"
        ],
        "operationId": "workflowAnalyticsReporting",
        "parameters": [
          {
            "$ref": "#/parameters/applicationParam"
          },
          {
            "$ref": "#/parameters/workflowParam"
          },
          {
            "$ref": "#/parameters/reportingFromFilter"
          },
          {
            "$ref": "#/parameters/reportingUntilFilter"
          },
          {
            "$ref": "#/parameters/reportingMetricsFilter"
          },
          {
            "$ref": "#/parameters/reportingDetailsFilter"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Most recent workflow version analytics.",
            "schema": {
              "$ref": "#/definitions/WorkflowStatisticsSummaryResponseType"
            }
          },
          "404": {
            "description": "The reference workflow/version could not be found.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}/status-change": {
      "get": {
        "summary": "Returns list of status changes for the specified workflow",
        "tags": [
          "reporting"
        ],
        "operationId": "workflowStatusChanges",
        "parameters": [
          {
            "$ref": "#/parameters/applicationParam"
          },
          {
            "$ref": "#/parameters/workflowParam"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "All workflow status changes for the specified workflow",
            "schema": {
              "$ref": "#/definitions/WorkflowStatisticsSummaryResponseType"
            }
          },
          "404": {
            "description": "The reference workflow or application could not be found.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}/versions/{version}/status-change": {
      "get": {
        "summary": "Returns list of status changes for the specified workflow version",
        "tags": [
          "reporting"
        ],
        "operationId": "workflowVersionStatusChanges",
        "parameters": [
          {
            "$ref": "#/parameters/applicationParam"
          },
          {
            "$ref": "#/parameters/workflowParam"
          },
          {
            "$ref": "#/parameters/versionParam"
          }
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "All workflow status changes for the specified workflow version",
            "schema": {
              "$ref": "#/definitions/WorkflowStatisticsSummaryResponseType"
            }
          },
          "404": {
            "description": "The reference workflow or version or application could not be found.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/applications/{application}/workflows/{workflow}/versions/{version}/analytics/reporting": {
      "get": {
        "summary": "Returns metrics for the workflow version for a defined period.",
        "description": "Returns metrics for the workflow version for a defined period.\n",
        "tags": [
          "reporting"
        ],
        "operationId": "workflowVersionAnalyticsReporting",
        "parameters": [
          {
            "$ref": "#/parameters/applicationParam"
          },
          {
            "$ref": "#/parameters/workflowParam"
          },
          {
            "$ref": "#/parameters/versionParam"
          },
          {
            "$ref": "#/parameters/reportingFromFilter"
          },
          {
            "$ref": "#/parameters/reportingUntilFilter"
          },
          {
            "$ref": "#/parameters/reportingMetricsFilter"
          },
          {
            "$ref": "#/parameters/reportingDetailsFilter"
          }
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "Most recent workflow version analytics.",
            "schema": {
              "$ref": "#/definitions/WorkflowVersionStatisticsSummaryResponseType"
            }
          },
          "404": {
            "description": "The reference workflow/version could not be found.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/stepdata/adwords/userlists": {
      "get": {
        "summary": "Returns the user lists that the user has in his google adwords account.",
        "tags": [
          "stepdata"
        ],
        "consumes": [
          "application/x-www-form-urlencoded"
        ],
        "produces": [
          "application/json"
        ],
        "responses": {
          "200": {
            "description": "The response will contain an array of strings, each of them being one user list name."
          },
          "403": {
            "description": "The user has not set up google oauth integration and so there's no permision to access that resource",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          },
          "500": {
            "description": "Some problem happened while contacting google servers",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    },
    "/oauth/{clientAccount}": {
      "get": {
        "summary": "Starts the google oauth flow",
        "description": "Starts the google oauth flow by redirecting the user to a google domain URL\n",
        "tags": [
          "oauth"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/clientAccountParam"
          },
          {
            "$ref": "#/parameters/authParam"
          }
        ],
        "responses": {
          "302": {
            "description": "Redirects the user to a google domain where it will authenticate the user."
          }
        }
      }
    },
    "/translations/{translationId}/multiKeys": {
      "get": {
        "summary": "Returns information on all multi content keys of the translation resource.",
        "description": "Returns all the multi content translation keys from the translation resource specified. It will not return keys that do not\nhave associated variations or action parameters. \n",
        "tags": [
          "translations"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/translationParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Information on all available keys",
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/MulticopyKeyInfoRepresentation"
              }
            }
          }
        }
      }
    },
    "/translations/{translationId}/multiKeys/{multiKeyId}": {
      "get": {
        "summary": "Returns the copy information associated with the multi key",
        "description": "Returns the copy information associated with the multi key. The structure is always the same, independently of whether there\nare random variations, action parameters or languages. In such cases the maps key uses a default value: 'default' for languages \nand random variations and \"NO_PARAMETER\" for action parameters\n",
        "tags": [
          "translations"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/translationParam"
          },
          {
            "$ref": "#/parameters/multiKeyParam"
          }
        ],
        "responses": {
          "200": {
            "description": "Information on all available keys",
            "schema": {
              "$ref": "#/definitions/MulticopyKeyContentRepresentation"
            }
          }
        }
      }
    },
    "/applications/{application}/gdpr": {
      "post": {
        "summary": "Submits a user removal request",
        "description": "This endpoint is used to submit requests for user removals in the context of the GDPR legislation. After a successfull submission the user data will be removed within a maximum time of 30 days.\n",
        "tags": [
          "gdpr"
        ],
        "consumes": [
          "application/json"
        ],
        "produces": [
          "application/json"
        ],
        "parameters": [
          {
            "$ref": "#/parameters/applicationParam"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/GdprUserRemovalRequest"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "The request has been recorded successfully"
          },
          "404": {
            "description": "The referenced application could not be found.",
            "schema": {
              "$ref": "#/definitions/ErrorType"
            }
          }
        }
      }
    }
  },
  "definitions": {
    "NameType": {
      "type": "string",
      "description": "The unique name of the entity"
    },
    "IdType": {
      "description": "System wide unique identifier of the entity",
      "type": "string"
    },
    "ObjectWithIdType": {
      "type": "object",
      "required": [
        "id"
      ],
      "properties": {
        "id": {
          "$ref": "#/definitions/IdType"
        }
      }
    },
    "VersionType": {
      "type": "number",
      "description": "The version number"
    },
    "ObjectWithVersionType": {
      "type": "object",
      "properties": {
        "version": {
          "$ref": "#/definitions/VersionType"
        }
      }
    },
    "ErrorType": {
      "type": "object",
      "required": [
        "errorType",
        "message"
      ],
      "properties": {
        "errorType": {
          "$ref": "#/definitions/ErrorTypeEnum"
        },
        "message": {
          "type": "string",
          "description": "A human readable message containing more details about the error.\n"
        },
        "innerErrors": {
          "description": "Details about what caused this error. This is not used when error type is INCOMING_REFERENCE_ERROR",
          "type": "array",
          "items": {
            "type": "object",
            "required": [
              "errorType",
              "message"
            ],
            "properties": {
              "errorType": {
                "$ref": "#/definitions/ErrorTypeEnum"
              },
              "errorSubtype": {
                "type": "string",
                "description": "An optional subtype of the error type. This can be useful to identify methods to automatically handle/display the error.",
                "enum": [
                  "UNKNOWN",
                  "UNPARSEABLE_REQUEST",
                  "MISSING_REQUIRED_FIELD",
                  "UNEXPECTED_FIELD",
                  "INVALID_REFRENCE",
                  "INVALID_NAME",
                  "CYCLICAL_WORKFLOW"
                ]
              },
              "errorPath": {
                "type": "string",
                "description": "A simple JSONPath representation of the error location. The format is of the form \"$.keyName.keyName.....propertyName\". Does not support\narrays at the moment. The context (represented by $) is always the root level object that was sent by the caller.\n"
              },
              "message": {
                "type": "string",
                "description": "A more human readable message containing more details about the error. If we cannot extract the error\nlocation in the 'errorPath' format, this message may contain some human readable location information.\n"
              }
            }
          }
        },
        "incomingReferenceErrors": {
          "description": "Reference errors when error type is INCOMING_REFERENCE_ERROR",
          "type": "array",
          "items": {
            "type": "object",
            "required": [
              "entityType",
              "url",
              "errorPath",
              "message"
            ],
            "properties": {
              "entityType": {
                "type": "string",
                "description": "The type of the refering entity",
                "enum": [
                  "WORKFLOW",
                  "WORKFLOW_VERSION",
                  "AB_TEST",
                  "TRANSLATION_RESOURCE"
                ]
              },
              "url": {
                "type": "string",
                "description": "The URL of the refering entity"
              },
              "errorPath": {
                "type": "string",
                "description": "Path within the refering entity that contains the reference (not fully implemented)"
              },
              "message": {
                "type": "string",
                "description": "Descriptive message of the error"
              }
            }
          }
        }
      }
    },
    "ErrorTypeEnum": {
      "description": "The top level type of the error. The type of errors continuously expands, so new enum values may be added often.",
      "type": "string",
      "enum": [
        "INTERNAL_SERVER_ERROR",
        "CREATE_FAILED",
        "UPDATE_FAILED",
        "ENTITY_NOT_FOUND",
        "MALFORMED_REQUEST",
        "INVALID_REQUEST",
        "PERMISSION_DENIED",
        "NAME_CONFLICT",
        "INCOMING_REFERENCE_ERROR"
      ]
    },
    "PagingType": {
      "type": "object",
      "properties": {
        "total": {
          "type": "number",
          "description": "total results"
        },
        "page": {
          "type": "number",
          "description": "The number of the current page"
        },
        "perPage": {
          "type": "number",
          "description": "Number of results per page"
        },
        "previous": {
          "type": "string",
          "description": "Link to previous page (if exists)"
        },
        "next": {
          "type": "string",
          "description": "Link to next page (if exists)"
        },
        "first": {
          "type": "string",
          "description": "Link to first page"
        },
        "last": {
          "type": "string",
          "description": "Link to last page"
        }
      }
    },
    "WorkflowExecutionMode": {
      "type": "string",
      "description": "Defines how the lifecycle of existing workflow instances will be affected by new executions of the workflow",
      "enum": [
        "ONCE",
        "REPEATABLE",
        "MOST_RECENT"
      ]
    },
    "WorkflowControlGroupSize": {
      "type": "number",
      "format": "int32",
      "description": "Percentage of the population that should belong to the workflow version control group."
    },
    "WorkflowControlGroupSeed": {
      "type": "string",
      "description": "A seed for the workflow version control group. Control groups with the same seeds and test sizes will result in groups with the exact same users.\nTo share the same control group populations across different vesions of a workflow, all versions must share the same seed value.\n"
    },
    "WorkflowStatusType": {
      "type": "string",
      "description": "The status of the entity. Not all values might be relevant for all entities.\n",
      "enum": [
        "ACTIVE",
        "PUBLISHED",
        "DELETED",
        "DRAFT"
      ]
    },
    "UserDataDictionaryType": {
      "description": "Defines the list of attributes that will potentially appear within the user context of incoming events.\n",
      "type": "object",
      "properties": {
        "description": {
          "description": "An optional, user-provided, description of the data contained in the data dictionary.",
          "type": "string"
        },
        "attributes": {
          "description": "The list of user attributes",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AttributeDefinition"
          }
        }
      }
    },
    "UserDataDictionaryUpdateResponse": {
      "description": "The response to an update operation on the user data types. It will contain the original request object and an additional validationErrors field that will contain any validation errors that prevented the update from happening.\n",
      "allOf": [
        {
          "$ref": "#/definitions/UserDataDictionaryType"
        },
        {
          "type": "object",
          "properties": {
            "validationErros": {
              "$ref": "#/definitions/UserDataDictionaryValidationErrorsType"
            }
          }
        }
      ]
    },
    "UserDataDictionaryValidationErrorsType": {
      "type": "object",
      "description": "Contains all the validation errors that might occur during an update operation of the user data types.\nOnly errors related to the attribute definitions in the user attributes pool can occur and these will be contained in the attributeErrors field. \n",
      "properties": {
        "attributeErrors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AttributeValidationErrorType"
          }
        }
      }
    },
    "EventDataDictionaryValidationErrorsType": {
      "type": "object",
      "description": "Contains all the validation errors that might occur during an update operation of the event data types.\nErrors related to the attribute definitions in the event attributes pool will be contained in the attributeErrors field. While errors related to the schema of a specific event type will be contained in the eventTypeErrors under the key that matches the event type constant.\n",
      "properties": {
        "attributeErrors": {
          "description": "Contains an entry for every attribute that didn't pass validation.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AttributeValidationErrorType"
          }
        },
        "eventTypeErrors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventTypeValidationErrorType"
          }
        }
      }
    },
    "EventTypeValidationErrorType": {
      "type": "object",
      "description": "Contains the validation errors for a specific event type.",
      "properties": {
        "eventType": {
          "type": "string",
          "description": "The event type code"
        },
        "errorMessage": {
          "type": "string",
          "description": "A description of the nature of the error"
        },
        "attributeErrors": {
          "description": "If there was a problem with the attributes associated with this event type, then this field will contain a list of the attribute validation errors.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AttributeValidationErrorType"
          }
        }
      }
    },
    "AttributeValidationErrorType": {
      "type": "object",
      "description": "Describes the kind of a validation error related with a user or event attribute",
      "properties": {
        "attributeName": {
          "type": "string",
          "description": "The name of the attribute"
        },
        "errorMessage": {
          "type": "string",
          "description": "A description of the nature of the error"
        }
      }
    },
    "EventsDataDictionaryType": {
      "description": "Defines the possible types of events and the list of attributes that are expected within each event type.\n",
      "type": "object",
      "properties": {
        "description": {
          "description": "An optional, user-provided, description of the data contained in the data dictionary.",
          "type": "string"
        },
        "attributes": {
          "description": "The list of event attributes",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AttributeDefinition"
          }
        },
        "eventTypes": {
          "description": "A list where each item is an object that specifies an event type and a list of attributes that are \nexpected for this event type.\n",
          "type": "array",
          "items": {
            "$ref": "#/definitions/EventTypeEntry"
          }
        }
      }
    },
    "EventsDataDictionaryUpdateResponse": {
      "description": "The response to an update operation on the event data types. It will contain the original request object and an additional validationErrors field that will contain any validation errors that prevented the update from happening.\n",
      "allOf": [
        {
          "$ref": "#/definitions/EventsDataDictionaryType"
        },
        {
          "type": "object",
          "properties": {
            "validationErrors": {
              "$ref": "#/definitions/EventDataDictionaryValidationErrorsType"
            }
          }
        }
      ]
    },
    "EventTypeEntry": {
      "description": "Schema information for a specific event type.",
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "the event type as a string constant"
        },
        "attributes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AttributeReference"
          },
          "description": "the list of attributes for this event type"
        }
      }
    },
    "AttributeReference": {
      "description": "References a specific attribute from the global pool of event attributes.",
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "the name of the attribute that is being referenced"
        },
        "mandatory": {
          "type": "boolean",
          "description": "indicates that this attribute must have a value for this event type."
        }
      }
    },
    "AttributeDefinition": {
      "description": "Defines an attribute that can appear within the user or event contexts.",
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "the name of the attribute"
        },
        "description": {
          "type": "string",
          "description": "an optional description for this attribute"
        },
        "type": {
          "$ref": "#/definitions/AttributeType"
        },
        "mandatory": {
          "type": "boolean",
          "description": "indicates that this attribute must have a value"
        },
        "editable": {
          "type": "boolean",
          "description": "indicates that this attribute can be changed in some way or not."
        }
      }
    },
    "AttributeType": {
      "description": "Enumeration of all supported data types for user and event attributes",
      "type": "string",
      "enum": [
        "bool",
        "text",
        "integer",
        "float",
        "datetime"
      ]
    },
    "OperatorType": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/OperatorItemType"
      }
    },
    "OperatorItemType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "a name for this operator"
        },
        "value": {
          "type": "string",
          "description": "a value that uniquely identifies this operator"
        }
      }
    },
    "PropertyValueType": {
      "type": "string"
    },
    "ClientAccountReturnProperties": {
      "type": "object",
      "description": "Extra return properties for the client account",
      "required": [
        "awsSecretValueInfo",
        "awsAccessKeyValueInfo",
        "mandrillApiKeyValueInfo",
        "sendgridApiKeyValueInfo"
      ],
      "properties": {
        "awsSecretValueInfo": {
          "$ref": "#/definitions/SecretValueType"
        },
        "awsAccessKeyValueInfo": {
          "$ref": "#/definitions/SecretValueType"
        },
        "mandrillApiKeyValueInfo": {
          "$ref": "#/definitions/SecretValueType"
        },
        "sendgridApiKeyValueInfo": {
          "$ref": "#/definitions/SecretValueType"
        }
      }
    },
    "ClientAccountPopulationProperties": {
      "type": "object",
      "description": "A client (data tiger customer)  entry that stores the client specific settings.",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the client account"
        },
        "description": {
          "type": "string",
          "description": "A description of the client account"
        },
        "email": {
          "type": "string",
          "description": "Primary e-mail of contact"
        },
        "phone": {
          "type": "string",
          "description": "Primary phone of contact"
        },
        "sendgridApiKey": {
          "type": "string",
          "description": "Sendgrid API key used for the sendgrid actions"
        },
        "mandrillApiKey": {
          "type": "string",
          "description": "Mandrill API key used for the mandrill actions"
        },
        "awsAccessKey": {
          "type": "string",
          "description": "AWS access key of the client's account. This is used by any actions that require to the client's customer's account (e.g. SNS Push action)"
        },
        "awsSecret": {
          "type": "string",
          "description": "AWS secret that corresponds to the AWS key of the client's account. This is used by any actions that require to the client's\ncustomer's account (e.g. SNS Push action)\n"
        },
        "awsRegion": {
          "type": "string",
          "description": "AWS region that corresponds to the AWS key of the client's account. This is used by any actions that require to the client's\ncustomer's account (e.g. SNS Push action)\n"
        }
      }
    },
    "ClientAccountTypePopulated": {
      "description": "A client (data tiger customer)  entry that stores the client specific settings.",
      "required": [
        "name",
        "email"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/ClientAccountReturnProperties"
        },
        {
          "$ref": "#/definitions/ClientAccountPopulationProperties"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        }
      ]
    },
    "ClientAccountTypeForUpdate": {
      "description": "A client (data tiger customer)  entry that stores the client specific settings.",
      "allOf": [
        {
          "$ref": "#/definitions/ClientAccountPopulationProperties"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        }
      ]
    },
    "ClientAccountTypeForCreation": {
      "description": "A client (data tiger customer)  entry that stores the client specific settings.",
      "required": [
        "name",
        "email"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/ClientAccountPopulationProperties"
        }
      ]
    },
    "LoginRequestType": {
      "type": "object",
      "description": "User login credentials",
      "required": [
        "username",
        "password"
      ],
      "properties": {
        "username": {
          "type": "string",
          "description": "the username associated with the user's account"
        },
        "password": {
          "type": "string",
          "description": "the password associated with the username."
        }
      }
    },
    "ChangePasswordRequestType": {
      "type": "object",
      "description": "User login credentials",
      "required": [
        "oldPassword",
        "newPassword"
      ],
      "properties": {
        "oldPassword": {
          "type": "string",
          "description": "The current (old) password of the user"
        },
        "newPassword": {
          "type": "string",
          "description": "The new password of the user. It must be longer than 8 characters."
        }
      }
    },
    "CoreUserAccountType": {
      "type": "object",
      "description": "Necessary information to create a user account, apart from the password",
      "properties": {
        "username": {
          "type": "string",
          "description": "The username of the user account"
        },
        "email": {
          "type": "string",
          "description": "The email of the user"
        },
        "firstName": {
          "type": "string",
          "description": "The first name of the user"
        },
        "lastName": {
          "type": "string",
          "description": "The last name of the user"
        },
        "contactNumber": {
          "type": "string",
          "description": "The contact number for the user"
        },
        "testUserId": {
          "type": "string",
          "description": "Optional user ID to be used for testing"
        }
      }
    },
    "ReturnedUserAccountType": {
      "description": "Information that is only returned but never provided",
      "type": "object",
      "properties": {
        "apikey": {
          "type": "string",
          "description": "The API key associated with this user. Currently API key is only returned when for the currently logged in user account."
        },
        "lastlogin": {
          "$ref": "#/definitions/ISODateTimeType"
        },
        "lastip": {
          "type": "string",
          "description": "Last access IP using this user account"
        }
      }
    },
    "CreateUserAccountType": {
      "description": "Necessary information to create a user account",
      "required": [
        "username",
        "email"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/CoreUserAccountType"
        }
      ]
    },
    "UpdateUserAccountType": {
      "description": "Necessary information to create a user account",
      "allOf": [
        {
          "$ref": "#/definitions/CoreUserAccountType"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        }
      ]
    },
    "UserAccountType": {
      "description": "Fully populated application information",
      "allOf": [
        {
          "$ref": "#/definitions/CoreUserAccountType"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        },
        {
          "$ref": "#/definitions/ReturnedUserAccountType"
        }
      ]
    },
    "PushTemplateTypeDerievedProperties": {
      "type": "object",
      "properties": {
        "requiresMessage": {
          "type": "boolean",
          "description": "True if this tempalte requires message to be set in the SNS Push action."
        },
        "requiresTitle": {
          "type": "boolean",
          "description": "True if this tempalte requires the title to be set in the SNS Push action."
        },
        "requiresImage": {
          "type": "boolean",
          "description": "True if this tempalte requires the image to be set in the SNS Push action."
        },
        "requiresVideo": {
          "type": "boolean",
          "description": "True if this tempalte requires the video to be set in the SNS Push action."
        }
      }
    },
    "CreatePushTemplateType": {
      "type": "object",
      "description": "Fully populated push template",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the tempalte"
        },
        "applicationId": {
          "type": "number",
          "description": "the accociated application"
        },
        "platform": {
          "$ref": "#/definitions/MobilePlatformType"
        },
        "type": {
          "type": "string",
          "description": "The type of the template. This must be consistent with the definition (e.g. for TEXT_WITH_IMAGE the definition must include \nfields action.snspush.image and action.snspush.message (no more or less fields)\n",
          "enum": [
            "TEXT",
            "TEXT_WITH_TITLE",
            "TEXT_WITH_IMAGE",
            "TEXT_WITH_TITLE_AND_IMAGE",
            "TEXT_WITH_VIDEO",
            "TEXT_WITH_TITLE_AND_VIDEO"
          ]
        },
        "definition": {
          "type": "string",
          "description": "The JSON that will be sent to SNS. The special strings ${action.snspush.message}, ${action.snspush.title}, ${action.snspush.image} and ${action.snspush.video}\nwill be replaced with the relevant values from the SNS Push action definition (and if used in the template they will be required\nto not be null. As an example, the defauilt template is:        \n{ \"default\": \"${action.snspush.message}\", \"APNS\": \"{\\\\\"aps\\\\\":{\\\\\"alert\\\\\": \\\"${action.snspush.message}\\\\\"} }\", \"GCM\":\"{\\\\\"data\\\\\":{\\\\\"message\\\\\": \\\\\"${action.snspush.message}\\\\\"}}\"} \n"
        }
      }
    },
    "PushTemplateType": {
      "type": "object",
      "description": "Fully populated push temp",
      "allOf": [
        {
          "$ref": "#/definitions/PushTemplateTypeDerievedProperties"
        },
        {
          "$ref": "#/definitions/CreatePushTemplateType"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        }
      ]
    },
    "CreateApplicationType": {
      "type": "object",
      "description": "Fully populated application information",
      "required": [
        "name"
      ],
      "properties": {
        "name": {
          "$ref": "#/definitions/NameType"
        },
        "description": {
          "type": "string",
          "description": "Description of this application"
        },
        "androidSnsApplicationArn": {
          "type": "string",
          "description": "(For the SNS Push action) The SNS ARN of the GCM application for sending Push notifications."
        },
        "iosSnsApplicationArn": {
          "type": "string",
          "description": "(For the SNS Push action) The SNS ARN of the IOS application for sending Push notifications."
        },
        "nightTimeStartMillis": {
          "type": "number",
          "format": "int64",
          "description": "Start of night, defined a milliseconds since 12:00AM (e.g. 22:00 is 79200000)",
          "default": 79200000
        },
        "nightTimeEndMillis": {
          "type": "number",
          "format": "int64",
          "description": "End of night, defined a milliseconds since 12:00AM (e.g. 9AM is 32400000)",
          "default": 32400000
        },
        "nightDeliveryAllowed": {
          "type": "boolean",
          "description": "If set to false, no deliveries will be performed at night (defined by  nightTimeStartMillis and nightTimeEndMillis).",
          "default": false
        }
      }
    },
    "ApplicationType": {
      "description": "Fully populated application information",
      "allOf": [
        {
          "$ref": "#/definitions/CreateApplicationType"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        },
        {
          "type": "object",
          "properties": {
            "supportsSNSPush": {
              "type": "boolean",
              "description": "True if application is setup for SNS pushes, false otherwise. If it's null/unspecified, the application may or may not be setup for SNS Pushes."
            }
          }
        }
      ]
    },
    "CoreTranslationResourceType": {
      "type": "object",
      "description": "Necessary information to create a translation resource",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the translation resource"
        },
        "url": {
          "type": "string",
          "description": "The URL of the translation resource. At the moment, google drive spreasheets are supported."
        },
        "metadata": {
          "type": "string",
          "description": "Optional metadata, specific to the individual resource. In the case of google spreadsheets, if a \nspreadsheet has a single sheet, metadata can be left empty. Otherwise it must specify the name of a sheet in the spreadsheet.\n"
        }
      }
    },
    "CreateTranslationResourceType": {
      "description": "Necessary information to create a translation resource",
      "required": [
        "name",
        "url"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/CoreTranslationResourceType"
        }
      ]
    },
    "UpdateTranslationResourceType": {
      "description": "Fields to update in an existing translation resource",
      "allOf": [
        {
          "$ref": "#/definitions/CoreTranslationResourceType"
        }
      ]
    },
    "PopulatedTranslationResourceType": {
      "description": "Fully populated translation resource",
      "required": [
        "name",
        "url"
      ],
      "allOf": [
        {
          "$ref": "#/definitions/CoreTranslationResourceType"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        }
      ]
    },
    "MulticopyKeyInfoRepresentation": {
      "type": "object",
      "description": "Multi key  metainformation. One or more of the following lists (languages, variations, actionParameters) will have >0 elements.",
      "required": [
        "key",
        "languages",
        "variations",
        "actionParameters",
        "platforms"
      ],
      "properties": {
        "key": {
          "type": "string",
          "description": "The key"
        },
        "languages": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The list of available languages. If the key has no language mappings and empty list will be returned"
        },
        "variations": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The list of random variations. These are labeled according to the suffixes in the document. If no variations exist for this key an empty list will be returned."
        },
        "platforms": {
          "description": "The list supported platforms",
          "type": "array",
          "items": {
            "$ref": "#/definitions/MobilePlatformType"
          }
        },
        "variationsType": {
          "description": "The type of variations, if there are variations (otherwise null)",
          "type": "string",
          "enum": [
            "RANDOM",
            "PROPERTY"
          ]
        },
        "actionParameters": {
          "type": "array",
          "description": "The list of parameter types defined by this key. If the key has no associated action parameters an empty list will be returned",
          "items": {
            "$ref": "#/definitions/ActionParameterTypeEnum"
          }
        }
      }
    },
    "ActionParameterTypeEnum": {
      "type": "string",
      "description": "Represents a parameter of an action. At the moment it only covers SNS push action parameters. NO_PARAMETER is used when \nan action parameter type is required, but none is available   \n",
      "enum": [
        "NO_PARAMETER",
        "ANDROID_TITLE",
        "ANDROID_MESSAGE",
        "ANDROID_IMAGE",
        "ANDROID_VIDEO",
        "IOS_TITLE",
        "IOS_MESSAGE",
        "IOS_IMAGE",
        "IOS_VIDEO"
      ]
    },
    "MulticopyKeyContentRepresentation": {
      "type": "object",
      "description": "Copies associated with the multi key",
      "required": [
        "key",
        "content"
      ],
      "properties": {
        "key": {
          "type": "string",
          "description": "The key"
        },
        "content": {
          "type": "object",
          "description": "Map from the language (or 'default' if no language variations exist) to the per-variation content map",
          "properties": {
            "language": {
              "$ref": "#/definitions/MulticopyKeyContentPerVariation"
            }
          },
          "additionalProperties": {
            "$ref": "#/definitions/MulticopyKeyContentPerVariation"
          }
        }
      }
    },
    "MulticopyKeyContentPerVariation": {
      "type": "object",
      "description": "Copies per variation. If there is no random variations, 'default' string is used as the map key.",
      "required": [
        "variation"
      ],
      "properties": {
        "variation": {
          "$ref": "#/definitions/MulticopyKeyContentPerAction"
        }
      },
      "additionalProperties": {
        "$ref": "#/definitions/MulticopyKeyContentPerAction"
      }
    },
    "MulticopyKeyContentPerAction": {
      "type": "object",
      "description": "Copy per action parameter. If no parameter is specified then 'NO_PARAMETER' will be used as the array key.",
      "required": [
        "parameter"
      ],
      "properties": {
        "parameter": {
          "type": "string"
        }
      },
      "additionalProperties": {
        "type": "string"
      }
    },
    "ABTestRefType": {
      "description": "The unique identifier of the AB test",
      "type": "string"
    },
    "ABTestType": {
      "description": "AB test object\n",
      "allOf": [
        {
          "$ref": "#/definitions/ObjectWithIdType"
        },
        {
          "$ref": "#/definitions/CreateABTestType"
        }
      ]
    },
    "CreateABTestType": {
      "type": "object",
      "description": "AB test object. The size sum of control group and the testGroups should be exactly 100\n",
      "required": [
        "name",
        "testGroups",
        "controlGroupSize"
      ],
      "properties": {
        "name": {
          "$ref": "#/definitions/NameType"
        },
        "description": {
          "description": "The user description for this AB test",
          "type": "string"
        },
        "applicationId": {
          "$ref": "#/definitions/IdType"
        },
        "seed": {
          "description": "A seed for the AB test. AB tests with the same seeds and test sizes will result in groups with the exact same users.",
          "type": "string"
        },
        "controlGroupSize": {
          "description": "Percentage of the population that should belong to the control group",
          "type": "number",
          "format": "int32"
        },
        "testGroups": {
          "description": "An array of the test groups for this AB test",
          "type": "array",
          "items": {
            "$ref": "#/definitions/TestGroupType"
          }
        }
      }
    },
    "TestGroupType": {
      "type": "object",
      "properties": {
        "name": {
          "description": "The name of the test group",
          "type": "string"
        },
        "size": {
          "description": "The size of the testgroup as a percentage (e.g. 20 is 20% of the population)",
          "type": "number",
          "format": "int32"
        }
      }
    },
    "TagType": {
      "type": "object",
      "properties": {
        "name": {
          "description": "The name of the tag",
          "type": "string"
        },
        "id": {
          "description": "Identifier of the tag",
          "type": "number",
          "format": "int32"
        }
      }
    },
    "SegmentType": {
      "type": "object",
      "properties": {
        "name": {
          "description": "The name of the segment",
          "type": "string"
        },
        "expression": {
          "description": "The expression assigned to the segment",
          "type": "string"
        },
        "id": {
          "description": "Identifier of the segment",
          "type": "number",
          "format": "int32"
        }
      }
    },
    "WorkflowStepTypeEnum": {
      "type": "string",
      "description": "Describes the type of a workflow step",
      "enum": [
        "START",
        "TERMINAL",
        "ACTION",
        "CONDITION",
        "WAIT",
        "SENDGRID_EMAIL_ACTION",
        "MANDRILL_EMAIL_ACTION",
        "SNS_PUSH_ACTION",
        "AB_SPLIT",
        "SNS_SMS",
        "ADWORDS_REMARKETING_ACTION",
        "TAG",
        "UNTAG"
      ]
    },
    "ExpressionType": {
      "type": "string",
      "description": "A boolean expression using the event and user dictionary.\n"
    },
    "WorkflowStepNameType": {
      "type": "string",
      "description": "the name of the step. This is used to refer to the step within the workflow."
    },
    "WorkflowTypeEnum": {
      "type": "string",
      "description": "Describes the type of a workflow",
      "enum": [
        "SEGMENT_BASED",
        "EVENT_BASED"
      ]
    },
    "CreateWorkflowType": {
      "type": "object",
      "description": "Fully populated workflow information.\n",
      "required": [
        "applicationId",
        "name",
        "version"
      ],
      "properties": {
        "name": {
          "$ref": "#/definitions/NameType"
        },
        "applicationId": {
          "$ref": "#/definitions/IdType"
        },
        "version": {
          "$ref": "#/definitions/WorkflowVersionType"
        },
        "type": {
          "$ref": "#/definitions/WorkflowTypeEnum"
        }
      }
    },
    "NonVersionedWorkflowProperties": {
      "type": "object",
      "description": "The non-versioned properties of a workflow.\n",
      "required": [
        "applicationId",
        "name"
      ],
      "properties": {
        "name": {
          "$ref": "#/definitions/NameType"
        },
        "applicationId": {
          "$ref": "#/definitions/IdType"
        }
      }
    },
    "UpdateWorkflowType": {
      "type": "object",
      "description": "The non-versioned properties of a workflow.\n",
      "allOf": [
        {
          "$ref": "#/definitions/NonVersionedWorkflowProperties"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        }
      ]
    },
    "WorkflowType": {
      "description": "Full populated workflow type, including the identifier and version number.",
      "allOf": [
        {
          "$ref": "#/definitions/CreateWorkflowType"
        },
        {
          "$ref": "#/definitions/ObjectWithIdType"
        }
      ]
    },
    "WorkflowExecutionStatus": {
      "description": "Information about last time a scheduled workflow version was executed",
      "properties": {
        "workflowVersionId": {
          "type": "number"
        },
        "startTime": {
          "$ref": "#/definitions/ISODateTimeType",
          "description": "time at which execution of the scheduled campaign has started"
        },
        "endTime": {
          "$ref": "#/definitions/ISODateTimeType",
          "description": "time at which execution of the scheduled campaign has finished. Only available if execution status is FAILED or COMPLETED"
        },
        "estimatedCount": {
          "type": "number",
          "description": "Number of users expected to execute the workflow to"
        },
        "processedCount": {
          "type": "number",
          "description": "Number of users for which a workflow has already been executed"
        },
        "executionStatus": {
          "type": "string",
          "enum": [
            "WAITING",
            "IN_PROGRESS",
            "FAILED",
            "COMPLETED"
          ]
        }
      }
    },
    "WorkflowVersionType": {
      "type": "object",
      "description": "A version of a workflow. If type of the Workflow is SEGMENT_BASED, scheduledAt must be provided.\n",
      "required": [
        "name",
        "status",
        "steps",
        "triggerExpression"
      ],
      "properties": {
        "name": {
          "$ref": "#/definitions/NameType"
        },
        "applicationId": {
          "$ref": "#/definitions/IdType"
        },
        "status": {
          "$ref": "#/definitions/WorkflowStatusType"
        },
        "executionMode": {
          "$ref": "#/definitions/WorkflowExecutionMode"
        },
        "workflowControlGroupSize": {
          "$ref": "#/definitions/WorkflowControlGroupSize"
        },
        "workflowControlGroupSeed": {
          "$ref": "#/definitions/WorkflowControlGroupSeed"
        },
        "testMode": {
          "type": "boolean",
          "description": "Indicates that trigger expression will be triggered only for test users configured for the specified client. If it is not set, then it is set as false"
        },
        "triggerExpression": {
          "$ref": "#/definitions/ExpressionType"
        },
        "scheduledAt": {
          "$ref": "#/definitions/ISODateTimeType"
        },
        "steps": {
          "type": "array",
          "description": "A map of all the workflow steps. It's structured as a map of the\nstep name to the step definition.\n",
          "items": {
            "$ref": "#/definitions/WorkflowStepType"
          }
        }
      }
    },
    "WorkflowStepType": {
      "type": "object",
      "description": "Generic workflow step definition for all types of steps. These extend this definition by adding\nextra properties when necessary.\n",
      "discriminator": "type",
      "required": [
        "name",
        "type"
      ],
      "properties": {
        "type": {
          "$ref": "#/definitions/WorkflowStepTypeEnum"
        },
        "name": {
          "$ref": "#/definitions/WorkflowStepNameType"
        },
        "description": {
          "type": "string"
        },
        "transitions": {
          "type": "object",
          "description": "map from the transition name to the resulting workflow step.\n",
          "properties": {
            "transitionName": {
              "$ref": "#/definitions/WorkflowStepNameType"
            }
          },
          "additionalProperties": {
            "$ref": "#/definitions/WorkflowStepNameType"
          }
        }
      }
    },
    "ActionStepType": {
      "type": "object",
      "properties": {
        "nightDeliveryAllowed": {
          "type": "boolean",
          "description": "If false, action executions during the night (according to the application settings and the user timezone) are delayed until\nthe beginning of the day (the action will be executed during a one hour window after the beginning of the day). The value defaults\nto the one at the application settings at the time of the workflow creation. \n"
        }
      }
    },
    "START": {
      "description": "The workflow starting step.\n",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        }
      ]
    },
    "ACTION": {
      "description": "An action performing workflow step. The extra parameters customize the action.\n",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "$ref": "#/definitions/ActionStepType"
        },
        {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "the URL to invoke"
            },
            "numRetries": {
              "type": "number",
              "format": "int32",
              "description": "Number of retries before permanent failure"
            },
            "responseType": {
              "$ref": "#/definitions/AttributeType",
              "description": "Defines the type of the webhook's response"
            },
            "params": {
              "type": "object",
              "description": "the parameters to include in the invocation. This can take two forms:\n*  A list of user attributes names (named 'attributes') to include as <name>=<value> pairs in the HTTP request. \n*  Hardcoded name-value pairs. The values can also contain interpolation tokens of the form ${<ref>} where ref is a reference to a user attribute meaning \n   that the whole token will be replaced by the value of the referenced attribute.  E.g. the value \"Hello ${User.FirstName}\" will be interpolated to \n   \"Hello Fran\" if User.FirstName was \"Fran\" for the user associated with this workflow instance.\n",
              "properties": {
                "parameterName": {
                  "type": "string"
                }
              },
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "required": [
            "url"
          ]
        }
      ]
    },
    "SNS_PUSH_ACTION": {
      "description": "iosEnabled and androidEnabled must always be specified and at least one must be not null.\nAn action for sending Push notifications using Amazon SNS. There are two modes, manual and multikey.\nIn manual mode, there must be an androidTemplateId/iosTemplateId corresponding to the enabled \nplatforms. If a template is defined, then the corresponding\nmessage must also be provided as well as all other fields that are required by the template. In multikey mode all of \ntranslationId and multiKey. \n",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "$ref": "#/definitions/ActionStepType"
        },
        {
          "type": "object",
          "required": [
            "iosEnabled",
            "androidEnabled"
          ],
          "properties": {
            "androidTemplateId": {
              "type": "string",
              "description": "The SNS Push template to be used for android pushes"
            },
            "androidTitle": {
              "type": "string",
              "description": "The title of the android message"
            },
            "androidMessage": {
              "type": "string",
              "description": "The body of the android message"
            },
            "androidImageURL": {
              "type": "string",
              "description": "The URL of the android message image"
            },
            "androidVideoURL": {
              "type": "string",
              "description": "The URL of the andoir message video"
            },
            "iosTemplateId": {
              "type": "string",
              "description": "The SNS Push template to be used for IOS pushes"
            },
            "iosTitle": {
              "type": "string",
              "description": "The title of the IOS message"
            },
            "iosMessage": {
              "type": "string",
              "description": "The body of the IOS message"
            },
            "iosImageURL": {
              "type": "string",
              "description": "The URL of the IOS message image"
            },
            "iosVideoURL": {
              "type": "string",
              "description": "The URL of the IOS message video"
            },
            "translationId": {
              "type": "number",
              "description": "The id of a content resource that contains multicopy data."
            },
            "multiKey": {
              "type": "string",
              "description": "The multicopy key"
            },
            "variationProperty": {
              "type": "string",
              "description": "A string that should match the multicopy's property variations. This action parameter can only be not null if\nthe multikey has property variations. It can contain (and should most proably do) escapes such as ${user.userProperty} or ${event.eventProperty}.\nAn exact string match of the resolve value of this string and the multikey property variation is required\nfor succesfull action execution.\n"
            },
            "iosEnabled": {
              "type": "boolean",
              "description": "Whether multikey IOS push is enabled. This can only be true if the multikey content contains IOS content. Otherwise it should be false."
            },
            "androidEnabled": {
              "type": "string",
              "description": "Whether multikey Android push is enabled. This can only be true if the multikey content contains Android content. Otherwise it should be false."
            }
          }
        }
      ]
    },
    "SENDGRID_EMAIL_ACTION": {
      "description": "An action for sending an e-mail through SendGrid\n",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "$ref": "#/definitions/ActionStepType"
        },
        {
          "type": "object",
          "properties": {
            "templateId": {
              "type": "string",
              "description": "the id of the email template"
            },
            "from": {
              "type": "string",
              "description": "the email to appear in the From field of the email"
            },
            "replyTo": {
              "type": "string",
              "description": "the email to appear in the ReplyTo field of the email"
            },
            "emailTo": {
              "type": "string",
              "description": "the email address to send to"
            },
            "fromName": {
              "type": "string",
              "description": "the name/alias to appear in the From field of the email"
            },
            "replyToName": {
              "type": "string",
              "description": "the name/alias to appear in the ReplyTo field of the email"
            },
            "emailToName": {
              "type": "string",
              "description": "the name/alias to appear in the To field of the email"
            },
            "subject": {
              "type": "string",
              "description": "the email's subject"
            },
            "substitutions": {
              "type": "array",
              "description": "an array of objects that defines tokens in the email along with the associated replacement values for each token",
              "items": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string",
                    "description": "the token to be replaced, e.g. %NAME%"
                  },
                  "value": {
                    "type": "string",
                    "description": "the value to be inserted in the email in place of the token. This can be/contain references to user attributes\nusing the syntax ${<attribute>}, e.g. ${user.Email}.  The set of possible user attributes is defined through the data dictionaries.\n"
                  }
                }
              }
            }
          },
          "required": [
            "templateId",
            "from",
            "replyTo"
          ]
        }
      ]
    },
    "MANDRILL_EMAIL_ACTION": {
      "description": "An action for sending emails through Mandrill",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "$ref": "#/definitions/ActionStepType"
        },
        {
          "type": "object",
          "properties": {
            "fromName": {
              "type": "string",
              "description": "the name/alias to appear in the From field of the email"
            },
            "fromEmail": {
              "type": "string",
              "description": "the email to appear in the From field of the email"
            },
            "emailTo": {
              "type": "string",
              "description": "the email address to send the email to"
            },
            "subject": {
              "type": "string",
              "description": "the subject of the email"
            },
            "templateName": {
              "type": "string",
              "description": "the Mandrill template to use"
            },
            "tags": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "the Mandrill tags to be used while sending the email"
            },
            "globalMergeVars": {
              "type": "object",
              "description": "The Mandrill globalMergeVars to be substituted within the email \"var\":\"value\""
            },
            "templateContents": {
              "type": "object",
              "description": "The Mandrill template contents to be substituted by Mandrill"
            },
            "trackOpens": {
              "type": "boolean",
              "description": "Defines if Mandrill should track email open event"
            },
            "trackClicks": {
              "type": "boolean",
              "description": "Defines if Mandrill should track clicks to links within the email"
            }
          },
          "required": [
            "fromEmail",
            "emailTo",
            "subject",
            "templateName"
          ]
        }
      ]
    },
    "ADWORDS_REMARKETING_ACTION": {
      "description": "An action that adds the user to a Google Adwords remarketing user list.",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "$ref": "#/definitions/ActionStepType"
        },
        {
          "type": "object",
          "properties": {
            "userListName": {
              "type": "string",
              "description": "The user list name where the users will be added to. If the user list doesn\\'t exist, it will be created."
            },
            "toAdd": {
              "type": "string",
              "description": "The information to add. Right now it has to be the user email (Google Adwords offers more options which can be added.) Usually maps to an event or user field"
            },
            "userTTL": {
              "type": "number",
              "description": "Amount of days that the user will remain in the list. Or null if the user will not expire."
            }
          },
          "required": [
            "userListName",
            "toAdd"
          ]
        }
      ]
    },
    "WAIT": {
      "description": "Waits for a specified amount of time",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "type": "object",
          "properties": {
            "waitMode": {
              "type": "string",
              "enum": [
                "WAIT_FOR",
                "WAIT_UNTIL_USER_TIME",
                "WAIT_UNTIL_INSTANT",
                "WAIT_UNTIL_MORNING",
                "WAIT_CRON",
                "WAIT_BEST_TIME"
              ]
            },
            "duration": {
              "type": "string",
              "format": "int32",
              "description": "The amount of time units to wait, can be interpolated, so it can contain a string with format \"${<attribute>}\" to be substituted. Required if waitMode or bestTimeUnavailable is WAIT_FOR"
            },
            "timeUnit": {
              "type": "string",
              "enum": [
                "HOURS",
                "DAYS",
                "WEEKS",
                "MONTHS"
              ],
              "description": "Specifies the time unit, can be interpolated, so it can contain a string with format \"${<attribute>}\" to be substituted. Required if waitMode or bestTimeUnavailable is WAIT_FOR"
            },
            "waitUntilUserTime": {
              "$ref": "#/definitions/ISODateTimeType",
              "description": "Specifies the time to wait until, can be interpolated, so it can contain a string with format \"${<attribute>}\" to be substituted. Required if waitMode or bestTimeUnavailable is WAIT_UNTIL_USER_TIME"
            },
            "waitUntilInstant": {
              "$ref": "#/definitions/ISODateTimeType",
              "description": "Specifies the time to wait until, can be interpolated, so it can contain a string with format \"${<attribute>}\" to be substituted. Required if waitMode or bestTimeUnavailable is WAIT_UNTIL_INSTANT"
            },
            "cronExpression": {
              "type": "string",
              "description": "Cron expresssion representing the wait delay. Has to be valid cron expression. required if waitMode or bestTimeUnavailable is WAIT_CRON"
            },
            "bestTimeUnavailable": {
              "type": "string",
              "enum": [
                "WAIT_FOR",
                "WAIT_UNTIL_USER_TIME",
                "WAIT_UNTIL_INSTANT",
                "WAIT_UNTIL_MORNING",
                "WAIT_CRON"
              ],
              "description": "Wait mode to be used in case best time delivery is not available for the user. Required if waitMode is WAIT_BEST_TIME"
            },
            "waitBestTimeMaxDelay": {
              "type": "string",
              "format": "int32",
              "description": "The max amount of time units to wait when looking for best time delivery. Required if waitMode is WAIT_BEST_TIME"
            },
            "waitBestTimeMaxDelayTimeUnit": {
              "type": "string",
              "enum": [
                "HOURS",
                "DAYS",
                "WEEKS",
                "MONTHS"
              ],
              "description": "The max amount of time units to wait when looking for best time delivery. Required if waitMode is WAIT_BEST_TIME"
            }
          }
        }
      ]
    },
    "TAG": {
      "description": "Adds a tag to the user",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "type": "object",
          "properties": {
            "tagId": {
              "type": "number",
              "description": "Id of the tag to add to the user."
            }
          },
          "required": [
            "tagId"
          ]
        }
      ]
    },
    "UNTAG": {
      "description": "Removes a tag to the user",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "type": "object",
          "properties": {
            "tagId": {
              "type": "number",
              "description": "Id of the tag to remove from the user."
            }
          },
          "required": [
            "tagId"
          ]
        }
      ]
    },
    "SNS_SMS": {
      "description": "Sends a SMS through Amazon's SNS service",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "$ref": "#/definitions/ActionStepType"
        },
        {
          "type": "object",
          "properties": {
            "phone": {
              "type": "string",
              "description": "The phone number where the SMS will be sent. This must include the country code."
            },
            "message": {
              "type": "string",
              "description": "The text of the SMS message"
            },
            "maxPrice": {
              "type": "number",
              "format": "float",
              "description": "A double that specifies an upper limit on the price for sending this message. If a limit is specified, then SNS will cancel the delivery if the carrier is about to charge more than that.\nThis is specified always in USD.\n"
            },
            "senderId": {
              "type": "string",
              "description": "A text to appear as the sender of the SMS. This is supported in some countries, not all."
            }
          },
          "required": [
            "phone",
            "message"
          ]
        }
      ]
    },
    "TERMINAL": {
      "description": "Workflow ending step",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        }
      ]
    },
    "CONDITION": {
      "description": "A conditional step. Parameters:\n* expressions: A boolean expression. According to it's evaluation one of the 'TRUE' or 'FALSE' transitions will be executed.\n",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "type": "object",
          "properties": {
            "expression": {
              "type": "string",
              "description": "the expression to evaluate. This has the same semantics as the workflow trigger expression."
            },
            "duration": {
              "type": "number",
              "format": "int32",
              "description": "The amount of time units to wait"
            },
            "timeUnit": {
              "type": "string",
              "enum": [
                "HOURS",
                "DAYS",
                "WEEKS",
                "MONTHS"
              ],
              "description": "Specifies the time unit"
            }
          },
          "required": [
            "expression"
          ]
        }
      ]
    },
    "AB_SPLIT": {
      "description": "Splits the workflow according to the test group in which the user belongs to. Parameters:\n* abTestId: The ID of the A/B test associated with this split. The user will be classified to a test group or the control group. \nThe transition taken from this step will be the one whose name matches the test group in which the user was classified. If the\nuser was classified as being part of the control group then the corresponding transition will be the one named 'Control'.\n",
      "allOf": [
        {
          "$ref": "#/definitions/WorkflowStepType"
        },
        {
          "type": "object",
          "properties": {
            "abTestId": {
              "type": "string",
              "description": "The ID of the A/B test associated with this split"
            }
          },
          "required": [
            "abTestId"
          ]
        }
      ]
    },
    "AnalyticsReportingResponseType": {
      "type": "object",
      "description": "Contains the supported analytics metrics.",
      "properties": {
        "RETENTION": {
          "$ref": "#/definitions/AnalyticsMetricReport"
        }
      }
    },
    "AnalyticsMetricReport": {
      "type": "object",
      "description": "Contains the values for a specific metric.",
      "required": [
        "type",
        "metricDate"
      ],
      "properties": {
        "type": {
          "$ref": "#/definitions/AnalyticsTypeEnum"
        },
        "metricDate": {
          "type": "string",
          "description": "Metrics reference date formated as 'yyyy-MM-dd'. E.g. if the date is '2018-02-10', the 7 day retention metric compares users entering the workflow in '2018-02-04' and being \nactive on '2018-02-10'\n"
        },
        "nDayAnalytics": {
          "$ref": "#/definitions/MultiNDayAnalyticsMetricReport"
        }
      }
    },
    "MultiNDayAnalyticsMetricReport": {
      "type": "object",
      "description": "Metric values per n day (e.g. 2-day retention, 7-day retention and so on)",
      "required": [
        "2"
      ],
      "properties": {
        "2": {
          "$ref": "#/definitions/NDayAnalyticsMetricReport"
        },
        "7": {
          "$ref": "#/definitions/NDayAnalyticsMetricReport"
        },
        "14": {
          "$ref": "#/definitions/NDayAnalyticsMetricReport"
        },
        "30": {
          "$ref": "#/definitions/NDayAnalyticsMetricReport"
        }
      }
    },
    "NDayAnalyticsMetricReport": {
      "type": "object",
      "description": "Metric values of a specific start/ending measurement period",
      "properties": {
        "day": {
          "description": "The number of days that separate the start/ending measurements (e.g. 7 for 7 day retention)",
          "type": "number"
        },
        "ratio": {
          "description": "Ending measurement divided by starting mesurements. E.g. for 7 day retention it's the number of user that remain active in the 7th day\ndivided by the number of uses that entered the workflow\n",
          "type": "number"
        },
        "uplift": {
          "description": "It is the ratio minus the ratio of the workflow version control group.",
          "type": "number"
        }
      }
    },
    "AnalyticsTypeEnum": {
      "description": "Type of analytics metrics",
      "type": "string",
      "enum": [
        "RETENTION"
      ]
    },
    "ReportingResponseType": {
      "type": "object",
      "properties": {
        "request": {
          "$ref": "#/definitions/ReportingRequestType"
        },
        "groups": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/GroupValuesType"
          }
        }
      },
      "example": {
        "request": {
          "applicationId": 1234567890,
          "workflowId": 1234567890,
          "versionId": 1234567890,
          "start": "2017-09-01T11:00:00Z",
          "end": "2017-09-01T12:00:00Z",
          "aggregation": "HOUR"
        },
        "groups": [
          {
            "step": "Send_Email_Action",
            "transition": "ENTER",
            "values": [
              [
                "2017-09-01T11:00:00Z",
                100
              ],
              [
                "2017-09-01T12:00:00Z",
                200
              ]
            ]
          },
          {
            "step": "Send_Email_Action",
            "transition": "OK",
            "values": [
              [
                "2017-09-01T11:00:00Z",
                100
              ],
              [
                "2017-09-01T12:00:00Z",
                100
              ]
            ]
          },
          {
            "step": "Send_Email_Action",
            "transition": "ERROR",
            "values": [
              [
                "2017-09-01T12:00:00Z",
                100
              ]
            ]
          },
          {
            "step": "START",
            "transition": "OK",
            "values": [
              [
                "2017-09-01T11:00:00Z",
                100
              ],
              [
                "2017-09-01T12:00:00Z",
                200
              ]
            ]
          },
          {
            "step": "END",
            "transition": "ENTER",
            "values": [
              [
                "2017-09-01T11:00:00Z",
                100
              ],
              [
                "2017-09-01T12:00:00Z",
                200
              ]
            ]
          }
        ]
      }
    },
    "GroupValuesType": {
      "type": "object",
      "properties": {
        "step": {
          "description": "StepId of the step that the statistic applies to",
          "type": "string"
        },
        "transition": {
          "description": "Step transition that the statistic applies to",
          "type": "string"
        },
        "values": {
          "type": "array",
          "items": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      }
    },
    "ReportingRequestType": {
      "type": "object",
      "description": "Details the properties of the request object for the reporting endpoint",
      "properties": {
        "applicationId": {
          "type": "string"
        },
        "workflowId": {
          "type": "number"
        },
        "versionId": {
          "type": "number"
        },
        "start": {
          "$ref": "#/definitions/ISODateTimeType"
        },
        "end": {
          "$ref": "#/definitions/ISODateTimeType"
        },
        "aggregation": {
          "$ref": "#/definitions/TimeUnitType"
        }
      }
    },
    "PreviewRequestType": {
      "type": "object",
      "description": "Details the action to be previewed",
      "properties": {
        "workflowStep": {
          "$ref": "#/definitions/WorkflowStepType"
        },
        "userProperties": {
          "type": "object",
          "description": "A map of user properties to be used as user fields. If the action contains ${user.name}, should have an element with key 'name'"
        },
        "eventProperties": {
          "type": "object",
          "description": "A map of user properties to be used as event fields. If the action contains ${event.level}, should have an element with key 'level'"
        }
      }
    },
    "PreviewResultType": {
      "type": "object",
      "description": "Holds information about the result of executing an action",
      "properties": {
        "result": {
          "type": "string"
        }
      }
    },
    "SecretValueType": {
      "description": "Type of sensitive information value when returning results. \nEMPTY: The value is not populated. \nPOPULATED: The value is populated but it is not returned\nPOPULATED_PREFIX: The value is populated and a sample prefix is returned     \nPOPULATED_SUFFIX: The value is populated and a sample suffix is returned     \n",
      "type": "string",
      "enum": [
        "EMPTY",
        "POPULATED",
        "POPULATED_PREFIX",
        "POPULATED_SUFFIX"
      ]
    },
    "ISODateTimeType": {
      "description": "ISODateTimeType, ISO8601 date format with optional time part. For instance, 1970-01-18T09:19:41.204+0000\n",
      "type": "string",
      "format": "date-time"
    },
    "MobilePlatformType": {
      "description": "The type of a mobile platform",
      "type": "string",
      "enum": [
        "IOS",
        "ANDROID"
      ]
    },
    "TimeUnitType": {
      "description": "TimeUnit",
      "type": "string",
      "enum": [
        "HOURS",
        "DAYS",
        "WEEKS",
        "MONTHS"
      ]
    },
    "ValidateEventResponse": {
      "type": "object",
      "properties": {
        "invalidEventType": {
          "type": "boolean",
          "description": "indicates if the event type is invalid as it does not appear in the event data schema"
        },
        "missingAttributes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "A list of attributes that are required for this event type but were not found in the input event"
        },
        "conversionErrors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ConversionErrorType"
          },
          "description": "A list containing an item for every attribute for which it was not possible to convert\nthe given input value to the required type for this field, e.g. the input was a boolean \nwhile the event schema declares this field as a date.   \n"
        },
        "unknownUserAttributes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Contains a list of user attributes that were included in the user object of the input event\nbut are not declared in the user data schema.\n"
        },
        "unknownEventAttributes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Contains a list of event attributes that were included in the input event\nbut are not declared in the event data schema.\n"
        },
        "extraEventAttributes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Contains a list of event attributes that were included in the input event\nbut are not included in the declaration of this event type in the user data schema.\n"
        }
      }
    },
    "WorkflowVersionStatisticsSummaryResponseType": {
      "type": "object",
      "description": "daily workflow statistics",
      "properties": {
        "request": {
          "type": "object",
          "description": "Returns the values used to return the response",
          "properties": {
            "workflowId": {
              "type": "number"
            },
            "workflowVersionId": {
              "type": "number"
            },
            "from": {
              "type": "string",
              "description": "A ISO-8601 date that specifies the requested period. If it is not defined it returns statistics | of the last month",
              "format": "date"
            },
            "until": {
              "type": "string",
              "description": "A ISO-8601 date that defines the requested perdiod",
              "format": "date"
            },
            "metrics": {
              "type": "array",
              "description": "a list of returned metrics",
              "items": {
                "type": "string",
                "enum": [
                  "ActiveUsers",
                  "Sessions",
                  "Payers",
                  "Revenue",
                  "RetentionDay_00",
                  "RetentionDay_01",
                  "RetentionDay_02",
                  "RetentionDay_07",
                  "RetentionDay_14",
                  "RetentionDay_30"
                ]
              }
            }
          }
        },
        "dailyStatistics": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DailyWorkflowStatistics"
          },
          "description": "an array of daily statistics"
        },
        "sums": {
          "type": "object",
          "description": "aggregation (sums) of the daily information. If request parameter 'details' was false, then only this object will be returned",
          "properties": {
            "periods": {
              "$ref": "#/definitions/PeriodsWorkflowStatistics"
            }
          }
        }
      }
    },
    "WorkflowStatisticsSummaryResponseType": {
      "type": "object",
      "description": "daily workflow statistics",
      "properties": {
        "request": {
          "type": "object",
          "description": "Returns the values used to return the response",
          "properties": {
            "workflowId": {
              "type": "number"
            },
            "from": {
              "type": "string",
              "description": "A ISO-8601 date that specifies the requested period. If it is not defined it returns statistics | of the last month",
              "format": "date"
            },
            "until": {
              "type": "string",
              "description": "A ISO-8601 date that defines the requested perdiod",
              "format": "date"
            },
            "metrics": {
              "type": "array",
              "description": "a list of returned metrics",
              "items": {
                "type": "string",
                "enum": [
                  "ActiveUsers",
                  "Sessions",
                  "Payers",
                  "Revenue",
                  "RetentionDay_00",
                  "RetentionDay_01",
                  "RetentionDay_02",
                  "RetentionDay_07",
                  "RetentionDay_14",
                  "RetentionDay_30"
                ]
              }
            }
          }
        },
        "dailyStatistics": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/DailyWorkflowStatistics"
          },
          "description": "an array of daily statistics"
        },
        "sums": {
          "type": "object",
          "description": "aggregation (sums) of the daily information. If request parameter 'details' was false, then only this object will be returned",
          "properties": {
            "periods": {
              "$ref": "#/definitions/PeriodsWorkflowStatistics"
            }
          }
        }
      }
    },
    "ConversionErrorType": {
      "type": "object",
      "properties": {
        "attribute": {
          "type": "string",
          "description": "The name of the affected attribute"
        },
        "expectedType": {
          "type": "string",
          "description": "The expected type for the attribute as declared in the event schema"
        },
        "actualType": {
          "type": "string",
          "description": "The deduced type for the attribute as given in the input event"
        }
      }
    },
    "GetEventsResponse": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "type": "object"
          },
          "description": "A list of events that matched the input search criteria,each event is represented by a JSON object\nwhose schema is customer specific\n"
        },
        "request": {
          "type": "object",
          "properties": {
            "userId": {
              "type": "string",
              "description": "the identifier of the user for which the events were found"
            },
            "applicationId": {
              "type": "string",
              "description": "the identifier of the application in which the user belongs"
            },
            "eventType": {
              "type": "string",
              "description": "if a value is set, then only events of this type will be returned\n"
            },
            "startTime": {
              "$ref": "#/definitions/ISODateTimeType"
            },
            "endTime": {
              "$ref": "#/definitions/ISODateTimeType"
            }
          }
        }
      }
    },
    "PeriodsWorkflowStatistics": {
      "type": "object",
      "description": "The date window that define the population each metric is measuring. Typically, retention metrics use a 1 day window period while other \nmetrics a 30 day window period.\n",
      "properties": {
        "PRIOR_1_DAY": {
          "$ref": "#/definitions/WorkflowPopulationSetStatistics"
        },
        "PRIOR_30_DAYS": {
          "$ref": "#/definitions/WorkflowPopulationSetStatistics"
        }
      }
    },
    "WorkflowPopulationSetStatistics": {
      "type": "object",
      "properties": {
        "CONTROL": {
          "$ref": "#/definitions/WorkflowPopulationStatistics",
          "description": "total population of control group"
        },
        "TEST": {
          "$ref": "#/definitions/WorkflowPopulationStatistics",
          "description": "total population of test group"
        }
      }
    },
    "DailyWorkflowStatistics": {
      "type": "object",
      "properties": {
        "calculatedOn": {
          "type": "string",
          "description": "A ISO-8601 date that specifies the",
          "format": "date"
        },
        "periods": {
          "$ref": "#/definitions/PeriodsWorkflowStatistics"
        }
      }
    },
    "WorkflowPopulationStatistics": {
      "type": "object",
      "properties": {
        "population": {
          "type": "number",
          "description": "In case of metrics such as DAUs this should be the population over the metric window (e.g. people affected last month). |\nFor retention metrics, it will most probably be people affected on the individual day.\n"
        },
        "usersAffected": {
          "type": "number",
          "description": "Unique users affected on the measurement day. This is the date in the workflowStatistics\n"
        },
        "totalPopulationMultiplier": {
          "type": "number",
          "description": "Multiplier to get the value as if it was for the total population. This should be used for normalising everything in the graphs. |\nA good way to calculate that would be (Test population + Control population) / thisPopulation\n"
        },
        "testGroup": {
          "type": "string",
          "description": "The test group of the AB test, if the population corresponds to an AB test. Otherwise it will be empty.\n"
        },
        "controlGroup": {
          "type": "boolean",
          "description": "True if the population corresponds to a workflow or AB group control group. False otherwise.\n"
        },
        "metrics": {
          "type": "object",
          "description": "map of available metrics e.g. ActiveUsers, Sessions, Payers, Revenue, RetentionDay_00, etc",
          "properties": {
            "ActiveUsers": {
              "$ref": "#/definitions/WorkflowMetricStatistics"
            },
            "Sessions": {
              "$ref": "#/definitions/WorkflowMetricStatistics"
            },
            "Payers": {
              "$ref": "#/definitions/WorkflowMetricStatistics"
            },
            "Revenue": {
              "$ref": "#/definitions/WorkflowMetricStatistics"
            },
            "RetentionDay_1": {
              "$ref": "#/definitions/WorkflowMetricStatistics"
            },
            "RetentionDay_2": {
              "$ref": "#/definitions/WorkflowMetricStatistics"
            }
          }
        }
      }
    },
    "WorkflowMetricStatistics": {
      "type": "object",
      "properties": {
        "value": {
          "type": "number",
          "description": "The value of the metrics for the associated population"
        },
        "projections": {
          "type": "object",
          "description": "a projected value based on one prediction model, currently supported PopulationsRatio",
          "properties": {
            "PopulationsRatio": {
              "$ref": "#/definitions/WorkflowPredictionStatistics"
            }
          }
        },
        "weightedSumOfValues": {
          "type": "number",
          "description": "Used only under 'sums' or other aggregations. It will be the weighted sum of all values for this metric."
        },
        "population": {
          "type": "number",
          "description": "Used only under 'sums' or other aggregations. It will be the population that corresponds to this metric."
        },
        "usersAffected": {
          "type": "number",
          "description": "Used only under 'sums' or other aggregations. It will be the affected users that corresponds to this metric."
        },
        "totalPopulationMultiplier": {
          "type": "number",
          "description": "Used only under 'sums' or other aggregations. It will be the population multiplier that corresponds to this metric."
        }
      }
    },
    "WorkflowPredictionStatistics": {
      "type": "object",
      "properties": {
        "predictedValue": {
          "type": "number"
        },
        "confidence": {
          "type": "number"
        },
        "weightedSumOfValues": {
          "type": "number",
          "description": "Used only under 'sums' or other aggregations. It will be the weighted sum of all values for this metric."
        },
        "controlScaledPredictedValue": {
          "type": "number",
          "description": "the revant control group adjusted to the size of this test group. Therefore, predictedValue - controlScaledPredictedValue will give the uplift\nin absolute numbers. In case of AB tests, if there is no control group, the BE will choose the worst performing test group as the \ncontrol group. \n"
        },
        "weightedSumOfControlScaledPredictedValue": {
          "type": "number",
          "description": "Used only under 'sums' or other aggregations. It will be the weighted sum of all controlScaledPredictedValue values."
        }
      }
    },
    "GdprUserRemovalRequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "string",
          "description": "the ID of the user to be removed"
        }
      }
    }
  },
  "parameters": {
    "authParam": {
      "name": "Authorization",
      "in": "header",
      "required": false,
      "type": "string",
      "description": "Bearer <API_Token>. Include this for API Token authentication"
    },
    "clientAccountParam": {
      "name": "clientAccount",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The identifier of the client account. The identifier 'me' always refers to the client that corresponds to the currently logged in user account."
    },
    "useraccountparam": {
      "name": "useraccountid",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The identifier of the user account. The identifier 'me' always refers to the currently logged in user account."
    },
    "applicationParam": {
      "name": "application",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The identifier of the application"
    },
    "translationParam": {
      "name": "translationId",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The identifier of the translation resource"
    },
    "translationKeyParam": {
      "name": "translationKeyId",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The identifier of the translation key id"
    },
    "multiKeyParam": {
      "name": "multiKeyId",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The identifier of the multi key"
    },
    "workflowParam": {
      "name": "workflow",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The identifier for the workflow"
    },
    "versionParam": {
      "name": "version",
      "in": "path",
      "required": true,
      "type": "number",
      "description": "The identifier for the workflow version"
    },
    "nameFilter": {
      "name": "name",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "Name prefix of the requested entity. If not specified, then all names are returned."
    },
    "urlFilter": {
      "name": "url",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "URL prefix."
    },
    "IdFilter": {
      "name": "id",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "The identifier to be fetched"
    },
    "statusFilter": {
      "name": "status",
      "in": "query",
      "required": false,
      "description": "One or more states to return. If not specified, then all states are returned.",
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ACTIVE",
          "INACTIVE",
          "COMPLETED",
          "DELETED",
          "CANCELED",
          "PENDING",
          "FAILED"
        ]
      }
    },
    "clientAccountIdParam": {
      "name": "clientAccountId",
      "in": "query",
      "required": false,
      "type": "number",
      "description": "Optional identifier of the client account. This can only be used by domain administrators that have access to multiple client accounts."
    },
    "pagingPageParam": {
      "name": "page",
      "in": "query",
      "required": false,
      "type": "number",
      "description": "Which page of the results to fetch"
    },
    "pagingPerPageParam": {
      "name": "perPage",
      "in": "query",
      "required": false,
      "type": "number",
      "description": "Results per page"
    },
    "usernameFilter": {
      "name": "username",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "Username prefix of the the user accounts"
    },
    "emailFilter": {
      "name": "email",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "Email prefix of the user accounts"
    },
    "firstNameFilter": {
      "name": "firstName",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "First name prefix of the user accounts"
    },
    "lastNameFilter": {
      "name": "lastName",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "Last name prefix of the user accounts"
    },
    "WorkflowSortingParam": {
      "name": "orderby",
      "description": "Fields to sort by. Field name is for ascending order, -fieldName (prefixed by a '-') is for descending order",
      "in": "query",
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "name",
          "-name"
        ]
      }
    },
    "dateFromFilter": {
      "name": "fromTime",
      "in": "query",
      "required": false,
      "description": "Starting date of validity. Format: 'UNIX timestamp'",
      "type": "string"
    },
    "dateToFilter": {
      "name": "endTime",
      "in": "query",
      "required": false,
      "description": "Ending date of validity, Format: 'UNIX timestamp'",
      "type": "string"
    },
    "ABTestsSortingParam": {
      "name": "orderby",
      "description": "Fields to sort by. Field name is for ascending order, -fieldName for descending order",
      "in": "query",
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "name",
          "-name"
        ]
      }
    },
    "abTestParam": {
      "name": "abTest",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The id of the AB test"
    },
    "tagParam": {
      "name": "tagId",
      "in": "path",
      "required": true,
      "type": "number",
      "description": "The id of the tag"
    },
    "segmentParam": {
      "name": "segmentId",
      "in": "path",
      "required": true,
      "type": "number",
      "description": "The id of the segment"
    },
    "ApplicationSortingParam": {
      "name": "orderby",
      "description": "Fields to sort by. Field name is for ascending order, -fieldName for descending order",
      "in": "query",
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "name",
          "-name"
        ]
      }
    },
    "TranslationSortingParam": {
      "name": "orderby",
      "description": "Fields to sort by. Field name is for ascending order, -fieldName for descending order",
      "in": "query",
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "name",
          "-name"
        ]
      }
    },
    "url": {
      "name": "url",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "URL prefix."
    },
    "reportingVersionFilter": {
      "name": "version",
      "in": "query",
      "required": true,
      "description": "The ID of the workflow version from which executions will be returned",
      "type": "number"
    },
    "reportingFromFilter": {
      "name": "from",
      "in": "query",
      "required": true,
      "description": "A ISO-8601 date that specifies the starting point from which executions will be returned",
      "type": "string",
      "format": "date-time"
    },
    "reportingUntilFilter": {
      "name": "until",
      "in": "query",
      "required": true,
      "description": "A ISO-8601 date-time that specifies the cut-off point after which executions will not be reported",
      "type": "string",
      "format": "date-time"
    },
    "reportingDetailsFilter": {
      "name": "details",
      "in": "query",
      "required": false,
      "type": "boolean",
      "default": true,
      "description": "If set to false, then only the aggregate values of the metrics are returned. This is very useful for displaying information such as the retention chart \n(where only the averages of a certain period are necessary).\n"
    },
    "reportingMetricsFilter": {
      "name": "metrics",
      "in": "query",
      "required": false,
      "type": "array",
      "collectionFormat": "multi",
      "items": {
        "type": "string"
      },
      "enum": [
        "Revenue",
        "Payers",
        "Sessions",
        "ActiveUsers",
        "RetentionDay_00",
        "RetentionDay_01",
        "RetentionDay_02",
        "RetentionDay_07"
      ],
      "description": "The metrics that are expected to return. It can be passed as prefix to return multple metrics e.g. 'Retention'.\nIt can accept multiple parameters e.g. metrics=Revenue&metrics=RetentionDay\n"
    },
    "reportingAggregationFilter": {
      "name": "aggregation",
      "in": "query",
      "required": false,
      "type": "string",
      "enum": [
        "HOURS",
        "DAYS",
        "WEEKS",
        "MONTHS"
      ],
      "description": "The time unit on which to aggregate the reported statistics.\n"
    },
    "getEventsUserIdFilter": {
      "name": "userId",
      "in": "query",
      "required": true,
      "type": "string",
      "description": "the identifier of the user for which the events were found"
    },
    "getEventsAppIdFilter": {
      "name": "appId",
      "in": "query",
      "required": true,
      "type": "string",
      "description": "the identifier of the application in which the user belongs"
    },
    "getEventsEventTypeFilter": {
      "name": "eventType",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "if a value is set, then only events of this type will be returned. \n"
    },
    "getEventsStartTimeFilter": {
      "name": "startTime",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "Defines the start of the data range that must contain the creation date of each event. If not defined, the start time will be set to half an hour ago.\n"
    },
    "getEventsEndTimeFilter": {
      "name": "endTime",
      "in": "query",
      "required": false,
      "type": "string",
      "description": "Defines the end of the data range that must contain the creation date of each event. If not defined it will default to one hour after the start time.\n"
    },
    "getEventsMaxResultsFilter": {
      "name": "maxResults",
      "in": "query",
      "required": false,
      "type": "number",
      "description": "Limits the number of events that will be returned by this call. If not set it will default to 50.\n"
    },
    "getUserPropertiesUserIdParam": {
      "name": "userId",
      "in": "path",
      "required": true,
      "type": "string",
      "description": "The identifier of the user whose properties should be returned"
    }
  }
}
